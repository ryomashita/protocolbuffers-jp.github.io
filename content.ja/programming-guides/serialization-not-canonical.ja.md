多くの人々が、シリアライズされた proto がその proto の内容を正確に表現することを望んでいます。使用例には次のものがあります:

- ハッシュテーブルのキーとしてシリアライズされた proto を使用する
- シリアライズされた proto のフィンガープリントやチェックサムを取る
- メッセージの等価性を確認する手段として、シリアライズされたペイロードを比較する

残念ながら、*protobuf のシリアライゼーションは（かつてもなく、できない）正準的ではありません*。MapReduce などのいくつかの例外はありますが、一般的には proto のシリアライゼーションを不安定と考えるべきです。このページではその理由を説明します。

## 決定論的は正準的ではない

決定論的なシリアライゼーションは正準的ではありません。シリアライザは、次の変更など、多くの理由により異なる出力を生成することができます:

1. protobuf スキーマがいかなる方法でも変更された場合
1. 構築中のアプリケーションがいかなる方法でも変更された場合
1. バイナリが異なるフラグ（例: opt と debug）でビルドされた場合
1. protobuf ライブラリが更新された場合

これは、シリアライズされた proto のハッシュが壊れやすく、時間や空間を超えて安定していないことを意味します。

シリアライズされた出力が変更される理由は多岐にわたります。上記のリストはすべてを網羅しているわけではありません。いくつかは、問題の領域に固有の難しさであり、正準的なシリアライゼーションを保証することが非効率的または不可能になる可能性があるものです。他のものは、最適化の機会を許すために意図的に未定義のままにしているものです。

## 安定したシリアライゼーションへの固有の障壁

Protobuf オブジェクトは、前方および後方互換性を提供するために未知のフィールドを保持します。未知のフィールドは正準的にシリアライズすることができません:

1. 未知のフィールドは、バイトとサブメッセージを区別できません。両方とも同じワイヤータイプを持っています。これにより、未知のフィールドに格納されたメッセージを正準化することが不可能になります。正準化する場合、未知のサブメッセージに再帰してフィールド番号でフィールドをソートする必要がありますが、これを行うための十分な情報がありません。
1. 効率のために、未知のフィールドは常に既知のフィールドの後にシリアライズされます。しかし、正準的なシリアライゼーションには、未知のフィールドをフィールド番号で既知のフィールドと交互に挿入する必要があります。これにより、その機能を使用していない人々にも効率とコードサイズのオーバーヘッドが発生します。

## 明示的に未定義とされた事柄

正準シリアル化が実現可能であったとしても（つまり、未知のフィールド問題を解決できるとしても）、より多くの最適化の機会を許すために、意図的にシリアル化順序を未定義のままにしています：

1. バイナリでフィールドが使用されていないことを証明できれば、スキーマから完全に削除し、未知のフィールドとして処理することができます。これにより、コードサイズとCPUサイクルを大幅に節約できます。
2. 同じフィールドのベクトルを一緒にシリアル化することで最適化の機会があるかもしれませんが、これはフィールド番号の順序を壊すことになります。

このような最適化の余地を残すために、いくつかの構成で意図的にフィールドの順序を入れ替え、アプリケーションが適切でない順序に依存しないようにします。
