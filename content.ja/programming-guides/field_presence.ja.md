## 背景 {/examples}

*フィールドの存在* とは、protobuf フィールドに値があるかどうかの概念です。
protobuf には、*存在しない* プレゼンスと、生成されたメッセージ API がフィールド値のみを保存する *明示的なプレゼンス* の 2 つの異なる表現があります。
proto2 は主に *明示的なプレゼンス* を採用してきましたが、proto3 は基本型の単数の proto3 フィールドについてのみ *存在しない* プレゼンスのセマンティクスを公開しています。
基本型（数値、文字列、バイト、および列挙型）の単数の proto3 フィールドは、`optional` ラベルで定義されており、proto2 と同様に *明示的なプレゼンス* を持っています（この機能はリリース 3.15 でデフォルトで有効になっています）。

### プレゼンスディシプリン {/examples}

*プレゼンスディシプリン* は、*API 表現* と *シリアライズされた表現* の間の変換のセマンティクスを定義します。
*存在しない* ディシプリンは、(デ)シリアライズ時にフィールド値自体を使用して決定を行います。
一方、*明示的なプレゼンス* ディシプリンは、明示的なトラッキング状態に依存します。

### *タグ値ストリーム*（ワイヤーフォーマット）シリアライゼーションにおけるプレゼンス {/examples}

ワイヤーフォーマットは、タグ付きの *自己区切り* 値のストリームです。
ワイヤーフォーマットは、定義上 *存在する* 値のシーケンスを表します。
つまり、シリアライゼーション内のすべての値は *存在する* フィールドを表し、さらに、シリアライゼーションには *存在しない* 値に関する情報が含まれていません。

proto メッセージの生成された API には、API 型と定義上 *存在する*（タグ、値）のペアのストリームとの間の変換を行う（デ）シリアライズ定義が含まれています。
この変換は、メッセージ定義の変更に対して前方および後方互換性がありますが、この互換性は、ワイヤーフォーマットのメッセージをデシリアライズする際にいくつかの（おそらく驚くべき）考慮事項を導入します。

-   シリアライズ時、*存在しない* フィールドは、デフォルト値を持つ場合にはシリアライズされません。
    -   数値型の場合、デフォルト値は0です。
    -   列挙型の場合、デフォルト値はゼロ値の列挙子です。
    -   文字列、バイト、繰り返しフィールドの場合、デフォルト値は長さゼロの値です。
    -   メッセージの場合、デフォルト値は言語固有のnull値です。
-   "空"の長さ区切り値（空の文字列など）は、シリアライズされた値で有効に表現できます：フィールドはワイヤーフォーマットに現れるという意味で「存在します」。ただし、生成されたAPIが存在を追跡していない場合、これらの値は再度シリアライズされないかもしれません。つまり、空のフィールドはシリアライズラウンドトリップ後に「存在しない」かもしれません。
-   デシリアライズ時、重複するフィールド値は、フィールドの定義に応じて異なる方法で処理される場合があります。
    -   重複する `repeated` フィールドは通常、フィールドのAPI表現に追加されます。（*packed* 繰り返しフィールドをシリアライズすると、タグストリームには1つの長さ区切り値のみが生成されることに注意してください。）
    -   重複する `optional` フィールド値は、「最後のものが勝つ」というルールに従います。
-   `oneof` フィールドは、APIレベルの不変条件を公開し、1つのフィールドのみが設定されていることを示します。ただし、ワイヤーフォーマットには複数の（タグ、値）ペアが含まれる場合があり、これらは概念的に `oneof` に属しています。`optional` フィールドと同様に、生成されたAPIは「最後のものが勝つ」ルールに従います。
-   proto2の生成APIでは、列挙型フィールドの範囲外の値は返されません。ただし、範囲外の値はAPI内で*未知のフィールド*として保存される場合がありますが、ワイヤーフォーマットのタグが認識された場合でもです。

### *Named-field Mapping* フォーマットにおける存在

Protobufは人間が読みやすいテキスト形式で表現することができます。2つの注目すべきフォーマットはTextFormat（生成されたメッセージの`DebugString`メソッドによって生成される出力形式）とJSONです。

これらのフォーマットにはそれぞれ独自の正確性要件があり、一般的には*tagged-value stream*フォーマットよりも厳格です。ただし、TextFormatはワイヤーフォーマットのセマンティクスにより密接に準拠し、一部のケースでは類似したセマンティクスを提供します（たとえば、繰り返し名前値マッピングを繰り返しフィールドに追加する）。特に、ワイヤーフォーマットと同様に、TextFormatには存在するフィールドのみが含まれます。

JSONははるかに厳格な形式ですが、ワイヤ形式やTextFormatの一部の意味を正しく表現できません。

- JSONの*要素*は意味的に順不同であり、各メンバーは一意の名前を持たなければなりません。これは、繰り返しフィールドのTextFormatのルールとは異なります。
- JSONには他の形式の*存在しない*ディシプリンとは異なり、"存在しない"フィールドを含めることができます。
    - JSONは`null`値を定義しており、これは*定義されているが存在しないフィールド*を表すために使用できます。
    - 繰り返しフィールドの値は、デフォルト値（空のリスト）と等しい場合でも、フォーマットされた出力に含めることができます。
- JSONの要素が順不同であるため、「最後に来たものが勝つ」ルールを曖昧さなく解釈する方法はありません。
    - ほとんどの場合、これは問題ありません：JSONの要素は一意の名前を持たなければならないため、繰り返しフィールドの値は有効なJSONではないため、TextFormatのように解決する必要はありません。
    - ただし、これは`oneof`フィールドを曖昧さなく解釈することができない可能性があることを意味します：複数のケースが存在する場合、それらは順不同です。

理論上、JSONは存在を意味を保持する方法で表現できます。しかし、実際には、実装の選択によって存在の正確性が異なる場合があります、特にJSONがprotobufを使用していないクライアントとの相互運用性を確保する手段として選択された場合。

### Proto2 APIにおける存在

この表は、proto2 APIのフィールドに対して存在が追跡されるかどうかを示しています（生成されたAPIと動的リフレクションを使用する場合の両方）：

フィールドの種類                                 | 明示的な存在
-------------------------------------------- | -----------------
単一の数値（整数または浮動小数点）                | ✔️
単一の列挙型                                   | ✔️
単一の文字列またはバイト列                        | ✔️
単一のメッセージ                                | ✔️
繰り返し                                      |
Oneof                                       | ✔️
マップ                                         |

単一のフィールド（すべてのタイプ）は、生成されたAPIで明示的に存在を追跡します。生成されたメッセージインターフェースには、フィールドの存在をクエリするためのメソッドが含まれています。例えば、フィールド`foo`には対応する`has_foo`メソッドがあります。（具体的な名前は、フィールドアクセサと同じ言語固有の命名規則に従います。）これらのメソッドは、protobufの実装内で「hazzers」と呼ばれることがあります。

同様に、単一のフィールドと同様に、`oneof` フィールドは明示的に、どのメンバーが値を含んでいるかを追跡します。例えば、次の `oneof` の例を考えてみてください：

```protobuf
oneof foo {
  int32 a = 1;
  float b = 2;
}
```

ターゲット言語によっては、生成された API には通常、いくつかのメソッドが含まれます：

-   `oneof` の hazzer: `has_foo`
-   *oneof case* メソッド: `foo`
-   メンバーの hazzer: `has_a`, `has_b`
-   メンバーのゲッター: `a`, `b`

繰り返しフィールドやマップは存在を追跡しません：*空の*繰り返しフィールドと*存在しない*繰り返しフィールドの区別はありません。

### Proto3 API における存在

この表は、proto3 API においてフィールドの存在が追跡されるかどうかを概説しています（生成された API および動的リフレクションを使用した場合の両方）：

フィールドの種類                                | `optional` | 明示的な存在
-------------------------------------------- | ---------- | -----------------
単一の数値（整数または浮動小数点）             | いいえ       |
単一の数値（整数または浮動小数点）             | はい       | ✔️
単一の列挙型                                 | いいえ       |
単一の列挙型                                 | はい       | ✔️
単一の文字列またはバイト列                    | いいえ       |
単一の文字列またはバイト列                    | はい       | ✔️
単一のメッセージ                             | いいえ       | ✔️
単一のメッセージ                             | はい       | ✔️
繰り返し                                     | N/A        |
Oneof                                      | N/A        | ✔️
マップ                                       | N/A        |

proto2 API と同様に、proto3 では繰り返しフィールドの存在を明示的に追跡しません。`optional` ラベルがない場合、proto3 API では基本型（数値、文字列、バイト列、列挙型）の存在を追跡しません。Oneof フィールドは存在を明示的に公開しますが、proto2 API と同様の hazzer メソッドのセットが生成されない場合もあります。

*存在しない* ディシプリンの下では、デフォルト値はシリアル化の目的において "存在しない" と同義です。フィールドを概念的に "クリア" するために（シリアル化されないようにするために）、API ユーザーはそれをデフォルト値に設定するでしょう。

デフォルト値は、*存在しない*状態の列挙型フィールドに対して、対応する0値の列挙子です。proto3構文のルールによると、すべての列挙型は、0にマップされる列挙子値を持つ必要があります。慣習として、これは `UNKNOWN` または同様の名前の列挙子です。ゼロ値がアプリケーションの有効な値のドメイン外にある場合、この動作は事実上 *明示的な存在* と見なすことができます。

## 意味の違い

*存在しない* シリアライゼーション規律は、デフォルト値が設定された場合に *明示的な存在* 追跡規律とは異なる見える違いをもたらします。数値、列挙型、または文字列型の単一フィールドに対して:

-   *存在しない* 規律:
    -   デフォルト値はシリアライズされません。
    -   デフォルト値は *マージされません*。
    -   フィールドを "クリア" するには、デフォルト値に設定します。
    -   デフォルト値は次の意味を持つ可能性があります:
        -   フィールドが明示的にデフォルト値に設定されたことを意味し、それがアプリケーション固有の値のドメインで有効である;
        -   フィールドがデフォルトに設定することで事実上 "クリア" された; または
        -   フィールドが設定されていない。
-   *明示的な存在* 規律:
    -   明示的に設定された値は常にシリアライズされ、デフォルト値も含まれます。
    -   設定されていないフィールドはマージされません。
    -   明示的に設定されたフィールド -- デフォルト値を含む -- はマージされます。
    -   生成された `has_foo` メソッドは、フィールド `foo` が設定されたかどうか (およびクリアされていないか) を示します。
    -   クリア (つまり、設定を解除) するには、生成された `clear_foo` メソッドを使用する必要があります。

### マージに関する考慮事項

*存在しない* 規則に従うと、ターゲットフィールドがデフォルト値からマージされることは事実上不可能です (protobuf の API マージ関数を使用して)。これは、デフォルト値がスキップされるためであり、*存在しない* シリアライゼーション規律と同様です。マージは、マージ先メッセージのみが更新され、更新元メッセージからスキップされない値を使用して行われます。

マージ動作の違いは、部分的な "パッチ" 更新に依存するプロトコルにさらなる影響を与えます。フィールドの存在が追跡されていない場合、更新パッチだけではデフォルト値への更新を表現できません。なぜなら、デフォルト値以外の値だけがマージされるからです。

更新してこの場合にデフォルト値を設定するには、`FieldMask`などの外部メカニズムが必要です。ただし、存在が追跡されている場合、すべての明示的に設定された値（デフォルト値も含む）がターゲットにマージされます。

### 変更互換性の考慮事項

フィールドを*明示的な存在*と*存在しない*の間で変更することは、ワイヤ形式のシリアライズされた値にとってバイナリ互換の変更です。ただし、メッセージのシリアライズに使用されたバージョンによって、メッセージのシリアライズされた表現が異なる場合があります。特に、"送信者"がフィールドをデフォルト値に明示的に設定した場合：

- *存在しない*の規律に従うシリアル化された値には、明示的に設定されたデフォルト値は含まれません。
- *明示的な存在*の規律に従うシリアル化された値には、デフォルト値を含むすべての"存在する"フィールドが含まれます。

この変更は、アプリケーションのセマンティクスによって安全であるかどうかが異なります。たとえば、メッセージ定義の異なるバージョンを使用する2つのクライアントを考えてみてください。

クライアントAは、フィールド`foo`に対して*明示的な存在*のシリアライズ規律に従うこのメッセージの定義を使用します：

```protobuf
syntax = "proto3";
message Msg {
  optional int32 foo = 1;
}
```

クライアントBは、同じメッセージの定義を使用しますが、*存在しない*の規律に従います：

```protobuf
syntax = "proto3";
message Msg {
  int32 foo = 1;
}
```

今、クライアントAがクライアントが繰り返し"同じ"メッセージを逆シリアル化および再シリアル化することで`foo`の存在を観察するシナリオを考えてみてください：

```protobuf
// Client A:
Msg m_a;
m_a.set_foo(1);                  // non-default value
assert(m_a.has_foo());           // OK
Send(m_a.SerializeAsString());   // to client B

// Client B:
Msg m_b;
m_b.ParseFromString(Receive());  // from client A
assert(m_b.foo() == 1);          // OK
Send(m_b.SerializeAsString());   // to client A

// Client A:
m_a.ParseFromString(Receive());  // from client B
assert(m_a.foo() == 1);          // OK
assert(m_a.has_foo());           // OK
m_a.set_foo(0);                  // default value
Send(m_a.SerializeAsString());   // to client B

// Client B:
Msg m_b;
m_b.ParseFromString(Receive());  // from client A
assert(m_b.foo() == 0);          // OK
Send(m_b.SerializeAsString());   // to client A

// Client A:
m_a.ParseFromString(Receive());  // from client B
assert(m_a.foo() == 0);          // OK
assert(m_a.has_foo());           // FAIL
```

クライアントAが`foo`に*明示的な存在*を依存している場合、クライアントBを経由する"ラウンドトリップ"は、クライアントAの観点から見ると損失が発生します。この例では、これは安全な変更ではありません：クライアントAは、フィールドが存在することを（`assert`によって）要求しており、APIを介しての変更がなくても、その要件は値とピアに依存する場合に失敗します。

## Proto3で*明示的な存在*を有効にする方法

これは、proto3のフィールド追跡サポートを使用する一般的な手順です。

1.  `.proto`ファイルに`optional`フィールドを追加します。
1.  `protoc`を実行します（少なくともv3.15、または`--experimental_allow_proto3_optional`フラグを使用してv3.12）。
1.  アプリケーションコードで生成された "hazzer"メソッドと "clear"メソッドを使用し、デフォルト値を比較または設定する代わりに。

### `.proto`ファイルの変更

これは、*存在しない*と*明示的な存在*セマンティクスの両方に従うフィールドを持つproto3メッセージの例です：

```protobuf
syntax = "proto3";
package example;

message MyMessage {
  // No presence:
  int32 not_tracked = 1;

  // Explicit presence:
  optional int32 tracked = 2;
}
```

### `protoc`の呼び出し

proto3メッセージの存在追跡は、デフォルトで有効になっています
[v3.15.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.15.0)
リリース以降、以前は
[v3.12.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.12.0) で
protocを使用する際に存在追跡を行うために`--experimental_allow_proto3_optional`フラグが必要でした。

### 生成されたコードの使用

*明示的な存在*（`optional`ラベル）を持つproto3フィールドの生成されたコードは、proto2ファイルであるかのようになります。

これは、"存在しない"例で使用される定義です：

```protobuf
syntax = "proto3";
package example;
message Msg {
  int32 foo = 1;
}
```

これは、"明示的な存在"例で使用される定義です：

```protobuf
syntax = "proto3";
package example;
message Msg {
  optional int32 foo = 1;
}
```

例では、`GetProto`関数が未指定の内容を持つ`Msg`型のメッセージを構築して返します。

#### C++の例

存在しない：

```c++
Msg m = GetProto();
if (m.foo() != 0) {
  // "Clear" the field:
  m.set_foo(0);
} else {
  // Default value: field may not have been present.
  m.set_foo(1);
}
```

明示的な存在：

```c++
Msg m = GetProto();
if (m.has_foo()) {
  // Clear the field:
  m.clear_foo();
} else {
  // Field is not present, so set it.
  m.set_foo(1);
}
```

#### C#の例

存在しない：

```c#
var m = GetProto();
if (m.Foo != 0) {
  // "Clear" the field:
  m.Foo = 0;
} else {
  // Default value: field may not have been present.
  m.Foo = 1;
}
```

明示的な存在：

```c#
var m = GetProto();
if (m.HasFoo) {
  // Clear the field:
  m.ClearFoo();
} else {
  // Field is not present, so set it.
  m.Foo = 1;
}
```

#### Goの例

存在しない：

```go
m := GetProto()
if m.Foo != 0 {
  // "Clear" the field:
  m.Foo = 0
} else {
  // Default value: field may not have been present.
  m.Foo = 1
}
```

明示的な存在：

```go
m := GetProto()
if m.Foo != nil {
  // Clear the field:
  m.Foo = nil
} else {
  // Field is not present, so set it.
  m.Foo = proto.Int32(1)
}
```

#### Javaの例

これらの例では、`Builder`を使用してクリアリングをデモンストレーションします。`Builder`からの存在の確認と値の取得は、メッセージ型と同じAPIに従います。

存在しない：

```java
Msg.Builder m = GetProto().toBuilder();
if (m.getFoo() != 0) {
  // "Clear" the field:
  m.setFoo(0);
} else {
  // Default value: field may not have been present.
  m.setFoo(1);
}
```

明示的な存在：

```java
Msg.Builder m = GetProto().toBuilder();
if (m.hasFoo()) {
  // Clear the field:
  m.clearFoo()
} else {
  // Field is not present, so set it.
  m.setFoo(1);
}
```

#### Pythonの例

存在しない：

```python
m = example.Msg()
if m.foo != 0:
  # "Clear" the field:
  m.foo = 0
else:
  # Default value: field may not have been present.
  m.foo = 1
```

明示的な存在：

```python
m = example.Msg()
if m.HasField('foo'):
  # Clear the field:
  m.ClearField('foo')
else:
  # Field is not present, so set it.
  m.foo = 1
```

#### Rubyの例

存在しない場合：

```ruby
m = Msg.new
if m.foo != 0
  # "Clear" the field:
  m.foo = 0
else
  # Default value: field may not have been present.
  m.foo = 1
end
```

明示的な存在：

```ruby
m = Msg.new
if m.has_foo?
  # Clear the field:
  m.clear_foo
else
  # Field is not present, so set it.
  m.foo = 1
end
```

#### Javascriptの例

存在しない場合：

```js
var m = new Msg();
if (m.getFoo() != 0) {
  // "Clear" the field:
  m.setFoo(0);
} else {
  // Default value: field may not have been present.
  m.setFoo(1);
}
```

明示的な存在：

```js
var m = new Msg();
if (m.hasFoo()) {
  // Clear the field:
  m.clearFoo()
} else {
  // Field is not present, so set it.
  m.setFoo(1);
}
```

#### Objective-Cの例

存在しない場合：

```objective-c
Msg *m = [[Msg alloc] init];
if (m.foo != 0) {
  // "Clear" the field:
  m.foo = 0;
} else {
  // Default value: field may not have been present.
  m.foo = 1;
}
```

明示的な存在：

```objective-c
Msg *m = [[Msg alloc] init];
if (m.hasFoo()) {
  // Clear the field:
  [m clearFoo];
} else {
  // Field is not present, so set it.
  [m setFoo:1];
}
```

## チートシート {#cheat}

**Proto2:**

フィールドの存在を追跡しますか？

フィールドの種類       | 追跡されますか？
---------------------- | --------
単一のフィールド       | はい
単一のメッセージフィールド | はい
oneof内のフィールド    | はい
繰り返しフィールド & マップ | いいえ

**Proto3:**

フィールドの存在を追跡しますか？

フィールドの種類       | 追跡されますか？
---------------------- | ------------------------
*その他* 単一のフィールド | `optional`として定義されている場合
単一のメッセージフィールド | はい
oneof内のフィールド    | はい
繰り返しフィールド & マップ | いいえ

**Edition 2023:**

フィールドの存在を追跡しますか？

フィールドの種類                                         | 追跡されますか？
-------------------------------------------------- | --------
デフォルト                                            | はい
`features.field_presence`が`LEGACY_REQUIRED`に設定されている場合 | はい
`features.field_presence`が`IMPLICIT`に設定されている場合        | いいえ
繰り返しフィールド & マップ                               | いいえ
```
