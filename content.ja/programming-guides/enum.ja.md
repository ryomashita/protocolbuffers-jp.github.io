## 列挙型の動作 {#definitions}

列挙型は、異なる言語ライブラリで異なる動作をします。このトピックでは、異なる動作と、protobuf をすべての言語で一貫した状態に移行する計画について説明します。一般的な列挙型の使用方法については、[proto2](/programming-guides/proto2#enum) および [proto3](/programming-guides/proto3#enum) 言語ガイドの対応するセクションを参照してください。

列挙型には、2 つの異なるフレーバー（*オープン* と *クローズド*）があります。未知の値の処理を除いて、それらは同じように動作します。実際には、単純なケースでは同じように動作しますが、いくつかの特殊なケースには興味深い影響があります。

説明のために、次の `.proto` ファイルがあると仮定しましょう（現時点では `syntax = "proto2"` または `syntax = "proto3"` ファイルであるかどうかは意図的に指定していません）:

```
enum Enum {
  A = 0;
  B = 1;
}

message Msg {
  optional Enum enum = 1;
}
```

*オープン* と *クローズド* の区別は、1 つの質問で表すことができます:

> プログラムが値 `2` を持つフィールド 1 を含むバイナリデータを解析するとき、何が起こりますか？

*   **オープン** 列挙型は値 `2` を解析し、それを直接フィールドに格納します。アクセサはフィールドを *設定* として報告し、`2` を表すものを返します。
*   **クローズド** 列挙型は値 `2` を解析し、メッセージの未知のフィールドセットに格納します。アクセサはフィールドを *未設定* として報告し、列挙型のデフォルト値を返します。

## *クローズド* 列挙型の影響

*クローズド* 列挙型の動作には、繰り返しフィールドを解析する際に予期しない結果があります。`repeated Enum` フィールドを解析すると、すべての未知の値が[未知のフィールド](/programming-guides/proto3/#unknowns)セットに配置されます。シリアライズされると、これらの未知の値は再度書き込まれますが、*元のリスト内の元の位置には書き込まれません*。たとえば、次の `.proto` ファイルが与えられた場合:

```
enum Enum {
  A = 0;
  B = 1;
}

message Msg {
  repeated Enum r = 1;
}
```

ワイヤーフォーマットには、フィールド1の値として `[0, 2, 1, 2]` を含むものがあります。この場合、繰り返しフィールドには `[0, 1]` が含まれ、値 `[2, 2]` は未知のフィールドとして格納されます。メッセージを再シリアル化した後、ワイヤーフォーマットは `[0, 1, 2, 2]` に対応します。

同様に、値が未知の場合、*closed* 列挙型を持つマップは、その値が未知の場合には、エントリ全体（キーと値）を未知のフィールドに配置します。

## 履歴 {#history}

`syntax = "proto3"` の導入以前、すべての列挙型は *closed* でした。Proto3 は *closed* 列挙型が引き起こす予期しない動作のために *open* 列挙型を導入しました。

## 仕様 {#spec}

以下は、protobuf の準拠実装の動作を指定しています。これは微妙な点であるため、多くの実装が準拠していません。異なる実装がどのように振る舞うかの詳細については、[既知の問題](#known-issues) を参照してください。

*   `proto2` ファイルが `proto2` ファイルで定義された列挙型をインポートする場合、その列挙型は **closed** として扱われるべきです。
*   `proto3` ファイルが `proto3` ファイルで定義された列挙型をインポートする場合、その列挙型は **open** として扱われるべきです。
*   `proto3` ファイルが `proto2` ファイルで定義された列挙型をインポートする場合、`protoc` コンパイラはエラーを出力します。
*   `proto2` ファイルが `proto3` ファイルで定義された列挙型をインポートする場合、その列挙型は **open** として扱われるべきです。

## 既知の問題 {#known-issues}

### C++ {#cpp}

すべての既知の C++ リリースは準拠していません。`proto2` ファイルが `proto3` ファイルで定義された列挙型をインポートする場合、C++ はそのフィールドを **closed** 列挙型として扱います。

### C# {#csharp}

すべての既知の C# リリースは準拠していません。C# はすべての列挙型を **open** として扱います。

### Java {#java}

すべての既知の Java リリースは準拠していません。`proto2` ファイルが `proto3` ファイルで定義された列挙型をインポートする場合、Java はそのフィールドを **closed** 列挙型として扱います。

> **注意:** Java における **open** 列挙型の扱いには驚くべきエッジケースがあります。次の定義が与えられた場合：
>
> ```
> syntax = "proto3";
>
> enum Enum {
>   A = 0;
>   B = 1;
> }
>
> message Msg {
>   repeated Enum name = 1;
> }
> ```
>
> Java は `Enum getName()` および `int getNameValue()` メソッドを生成します。`getName` メソッドは既知のセット外の値（たとえば `2` など）に対して `Enum.UNRECOGNIZED` を返し、`getNameValue` は `2` を返します。
>
> 同様に、Java は `Builder setName(Enum value)` および `Builder setNameValue(int value)` メソッドを生成します。`setName` メソッドは `Enum.UNRECOGNIZED` が渡された場合に例外をスローし、`setNameValue` は `2` を受け入れます。

### Kotlin {#java}

すべての既知のKotlinリリースは適合性を満たしていません。`proto2`ファイルが`proto3`ファイルで定義された列挙型をインポートすると、Kotlinはそのフィールドを**クローズド**列挙型として扱います。

KotlinはJava上に構築されており、そのすべての特異性を共有しています。

### Go {#go}

すべての既知のGoリリースは適合性を満たしていません。Goはすべての列挙型を**オープン**として扱います。

### JSPB {#jspb}

すべての既知のJSPBリリースは適合性を満たしていません。JSPBはすべての列挙型を**オープン**として扱います。

### PHP {#php}

PHPは適合しています。

### Python {#python}

4.22.0以降、Pythonは適合しています。

4.21.xでは、Pythonはデフォルトで適合していますが、`PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python`を設定すると適合性を満たさなくなります。

4.21.0より前では、Pythonは適合していません。

`proto2`ファイルが`proto3`ファイルで定義された列挙型をインポートすると、適合していないPythonバージョンはそのフィールドを**クローズド**列挙型として扱います。

### Ruby {#ruby}

すべての既知のRubyリリースは適合性を満たしていません。Rubyはすべての列挙型を**オープン**として扱います。

### Objective-C {#obj-c}

22.0以降、Objective-Cは適合しています。

22.0より前では、Objective-Cは適合していませんでした。`proto2`ファイルが`proto3`ファイルで定義された列挙型をインポートすると、そのフィールドを**クローズド**列挙型として扱いました。

### Swift {#swift}

Swiftは適合しています。

### Dart {#dart}

Dartはすべての列挙型を**クローズド**として扱います。
