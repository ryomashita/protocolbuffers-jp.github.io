
+++
title = "アプリケーションノート: フィールドの存在"
weight = 85
linkTitle = "フィールドの存在"
description = "protobufフィールドの存在を追跡するさまざまな手法について説明します。また、基本型を持つ単数のproto3フィールドの明示的な存在を追跡する動作についても説明します。"
type = "docs"
+++

## 背景

*フィールドの存在* とは、protobufフィールドが値を持っているかどうかという概念です。
protobufには、*フィールドの存在* の2つの異なる表現があります。*存在しない* 場合は、生成されたメッセージAPIがフィールド値のみを保存し、*明示的な存在* の場合は、APIがフィールドが設定されているかどうかも保存します。

歴史的に、proto2は主に *明示的な存在* を追跡してきましたが、proto3は *存在しない* セマンティクスのみを公開しています。基本型（数値、文字列、バイト、および列挙型）の単数のproto3フィールドは、`optional` ラベルで定義されており、proto2と同様に *明示的な存在* を持ちます（この機能はリリース3.15でデフォルトで有効になっています）。

### 存在の手法

*存在の手法* は、*API表現* と *シリアライズされた表現* の間の変換のセマンティクスを定義します。*存在しない* 手法は、(デ)シリアライズ時にフィールド値自体を使用して決定を行いますが、*明示的な存在* 手法は明示的な追跡状態に依存します。

### *タグ値ストリーム*（ワイヤーフォーマット）シリアライゼーションにおける存在

ワイヤーフォーマットは、タグ付きの *自己区切り* 値のストリームです。定義上、ワイヤーフォーマットは *存在する* 値のシーケンスを表します。つまり、シリアライゼーション内のすべての値は *存在する* フィールドを表し、さらに、シリアライゼーションには *存在しない* 値に関する情報が含まれていません。

protoメッセージの生成されたAPIには、APIタイプと定義上 *存在する* （タグ、値）のペアのストリームとの間の変換を行う（デ）シリアライズ定義が含まれています。この変換は、メッセージ定義の変更に対して前方および後方互換性がありますが、この互換性は、ワイヤーフォーマットのメッセージをデシリアライズする際にいくつかの（おそらく驚くべき）考慮事項を導入します。
```

-   シリアライズ時、*存在しない* フィールドは、デフォルト値を持つ場合にはシリアライズされません。
    -   数値型の場合、デフォルト値は 0 です。
    -   列挙型の場合、デフォルト値はゼロ値の列挙子です。
    -   文字列、バイト、繰り返しフィールドの場合、デフォルト値はゼロ長の値です。
    -   メッセージの場合、デフォルト値は言語固有の null 値です。
-   "空" の長さ区切り値（空の文字列など）は、シリアライズされた値で有効に表現できます：フィールドはワイヤーフォーマットに現れるという意味で "存在します"。ただし、生成された API が存在を追跡しない場合、これらの値は再度シリアライズされない可能性があります。つまり、空のフィールドはシリアライズのラウンドトリップ後に "存在しない" かもしれません。
-   デシリアライズ時、重複するフィールド値は、フィールドの定義に応じて異なる方法で処理される場合があります。
    -   重複する `repeated` フィールドは通常、フィールドの API 表現に追加されます。（*packed* 繰り返しフィールドをシリアライズすると、タグストリームには長さ区切りの値が 1 つだけ生成されることに注意してください。）
    -   重複する `optional` フィールド値は "最後のものが勝つ" ルールに従います。
-   `oneof` フィールドは、API レベルでの不変条件を公開します。つまり、1 回につき 1 つのフィールドのみが設定されています。ただし、ワイヤーフォーマットには複数の（タグ、値）ペアが含まれる場合があり、これらは概念的に `oneof` に属しています。`optional` フィールドと同様に、生成された API は "最後のものが勝つ" ルールに従います。
-   生成された proto2 API の列挙型フィールドでは、範囲外の値は返されません。ただし、範囲外の値は API に *未知のフィールド* として格納される場合がありますが、ワイヤーフォーマットのタグが認識された場合でもです。

### *Named-field Mapping* 形式における存在

Protobuf は人間が読みやすいテキスト形式で表現することができます。2 つの注目すべき形式は TextFormat（生成されたメッセージの `DebugString` メソッドによって生成される出力形式）と JSON です。

これらの形式にはそれぞれ独自の正確性要件があり、一般的には *tagged-value stream* 形式よりも厳格です。ただし、TextFormat はワイヤーフォーマットのセマンティクスにより密接に準拠し、一部のケースでは類似のセマンティクスを提供します（たとえば、繰り返し名前値マッピングを繰り返しフィールドに追加する）。特に、ワイヤーフォーマットと同様に、TextFormat は存在するフィールドのみを含みます。

JSONははるかに厳格な形式ですが、ワイヤ形式やTextFormatの一部の意味を正しく表現できません。

- JSONの*要素*は意味的に順序付けされておらず、各メンバーは一意の名前を持たなければなりません。これは、繰り返しフィールドのTextFormatのルールとは異なります。
- JSONには他の形式の*存在しない*ディシプリンとは異なり、"存在しない"フィールドを含めることができます：
    - JSONは`null`値を定義しており、これは*定義されているが存在しないフィールド*を表すために使用できます。
    - 空のリストである場合でも、繰り返しフィールドの値はフォーマットされた出力に含めることができます。
- JSON要素が順序付けされていないため、「最後に来たものが勝つ」ルールを曖昧さなく解釈する方法はありません。
    - ほとんどの場合、これは問題ありません：JSON要素は一意の名前を持たなければならないため、繰り返しフィールドの値は有効なJSONではないため、TextFormatのように解決する必要はありません。
    - ただし、これは`oneof`フィールドを曖昧さなく解釈することができない可能性があることを意味します：複数のケースが存在する場合、それらは順序付けされていません。

理論上、JSONは意味を保持した形式で存在を表現できます。しかし、実際には、特にJSONがprotobufを使用していないクライアントとの相互運用性を確保する手段として選択された場合、存在の正確性は実装の選択によって異なる可能性があります。

### Proto2 APIにおける存在

この表は、proto2 APIのフィールドに対して存在が追跡されているかどうかを示しています（生成されたAPIおよび動的リフレクションを使用する場合の両方）：

フィールドの種類                                | 明示的な存在
-------------------------------------------- | -----------------
単一の数値（整数または浮動小数点）               | ✔️
単一の列挙型                                 | ✔️
単一の文字列またはバイト                        | ✔️
単一のメッセージ                              | ✔️
繰り返し                                     |
Oneofs                                       | ✔️
マップ                                        |

単一のフィールド（すべてのタイプ）は、生成されたAPIで明示的に存在を追跡します。生成されたメッセージインターフェースには、フィールドの存在をクエリするためのメソッドが含まれています。たとえば、フィールド`foo`には対応する`has_foo`メソッドがあります。（具体的な名前は、フィールドアクセサと同じ言語固有の命名規則に従います。）これらのメソッドは、protobufの実装内で「hazzers」と呼ばれることがあります。

同様に、単数形のフィールドと同様に、`oneof` フィールドは明示的に、どのメンバーが値を含んでいるかを追跡します。たとえば、次の `oneof` の例を考えてみてください：

```protobuf
oneof foo {
  int32 a = 1;
  float b = 2;
}
```

ターゲット言語によっては、生成された API には通常、いくつかのメソッドが含まれます：

-   `oneof` の hazzer: `has_foo`
-   *oneof case* メソッド: `foo`
-   メンバーの hazzer: `has_a`, `has_b`
-   メンバーのゲッター: `a`, `b`

繰り返しフィールドやマップは存在を追跡しません：*空* と *存在しない* 繰り返しフィールドの間には区別がありません。

### Proto3 API における存在

この表は、proto3 API（生成された APIおよび動的リフレクションを使用する場合の両方）において、フィールドの存在が追跡されるかどうかを示しています：

フィールドの種類                                   | `optional` | 明示的な存在
-------------------------------------------- | ---------- | -----------------
単数の数値（整数または浮動小数点） | いいえ         |
単数の数値（整数または浮動小数点） | はい        | ✔️
単数の列挙型                                | いいえ         |
単数の列挙型                                | はい        | ✔️
単数の文字列またはバイト                     | いいえ         |
単数の文字列またはバイト                     | はい        | ✔️
単数のメッセージ                             | いいえ         | ✔️
単数のメッセージ                             | はい        | ✔️
繰り返しフィールド                                     | N/A        |
Oneof                                       | N/A        | ✔️
マップ                                         | N/A        |

proto2 API と同様に、proto3 では繰り返しフィールドの存在を明示的に追跡しません。`optional` ラベルがない場合、proto3 API では基本型（数値、文字列、バイト、および列挙型）の存在を追跡しません。Oneof フィールドは存在を明示的に公開しますが、proto2 API と同様の hazzer メソッドのセットが生成されない場合もあります。

*存在しない* ディシプリンの下では、デフォルト値はシリアル化の目的において "存在しない" と同義です。フィールドを概念的に "クリア" するために（シリアル化されないようにするために）、API ユーザーはそれをデフォルト値に設定するでしょう。

デフォルト値は、*存在しない* 状態の列挙型フィールドの場合、対応する0値の列挙子です。proto3 構文ルールによると、すべての列挙型は、0にマップされる列挙子値を持つ必要があります。慣習として、これは `UNKNOWN` などの名前のついた列挙子です。ゼロ値がアプリケーションの有効な値のドメイン外にある場合、この動作は事実上 *明示的な存在* と同等であると考えることができます。

## 意味上の違い

*存在しない* シリアライゼーション規律は、デフォルト値が設定された場合に *明示的な存在* 追跡規律とは異なる見える違いをもたらします。数値、列挙型、または文字列型の単一フィールドの場合：

-   *存在しない* 規律：
    -   デフォルト値はシリアライズされません。
    -   デフォルト値は *マージされません*。
    -   フィールドを "クリア" するには、デフォルト値に設定します。
    -   デフォルト値は次の意味を持つ可能性があります：
        -   フィールドが明示的にデフォルト値に設定されたことを意味し、それがアプリケーション固有の値のドメインで有効であること；
        -   デフォルトに設定することで、フィールドが "クリア" されたと考えられること；または
        -   フィールドが設定されていないこと。
-   *明示的な存在* 規律：
    -   明示的に設定された値は常にシリアライズされ、デフォルト値も含まれます。
    -   設定されていないフィールドはマージされません。
    -   明示的に設定されたフィールド（デフォルト値を含む）はマージされます。
    -   生成された `has_foo` メソッドは、フィールド `foo` が設定されているかどうか（クリアされていないか）を示します。
    -   `clear_foo` メソッドを使用して値をクリア（つまり、設定を解除）する必要があります。

### マージに関する考慮事項

*存在しない* 規則に従うと、ターゲットフィールドがデフォルト値からマージされることは事実上不可能です（protobuf の API マージ関数を使用して）。これは、デフォルト値がスキップされるためであり、*存在しない* シリアライゼーション規律と同様です。マージは、マージ先メッセージのみが更新され、更新元メッセージからスキップされない値を使用して行われます。

マージ動作の違いは、部分的な "パッチ" 更新に依存するプロトコルにさらなる影響を与えます。フィールドの存在が追跡されていない場合、更新パッチだけではデフォルト値への更新を表現できないため、デフォルト値への更新を表現できません。

更新してこの場合にデフォルト値を設定するには、`FieldMask` のような外部メカニズムが必要です。ただし、存在が追跡されている場合、すべての明示的に設定された値（デフォルト値も含む）がターゲットにマージされます。

### 変更互換性の考慮事項

フィールドを *明示的な存在* と *存在しない* の間で変更することは、ワイヤ形式でシリアル化された値に対してバイナリ互換の変更です。ただし、シリアル化されたメッセージの表現は、シリアル化に使用されたメッセージ定義のバージョンによって異なる場合があります。具体的には、"送信者" がフィールドをデフォルト値に明示的に設定した場合：

- *存在しない* ディシプリンに従うシリアル化された値には、明示的に設定されたデフォルト値は含まれません。
- *明示的な存在* ディシプリンに従うシリアル化された値には、デフォルト値を含む場合でもすべての "存在する" フィールドが含まれます。

この変更は、アプリケーションのセマンティクスによって安全であるかどうかが異なります。たとえば、メッセージ定義の異なるバージョンを使用する2つのクライアントを考えてみてください。

クライアント A は、`foo` フィールドに対して *明示的な存在* シリアル化ディシプリンに従うこのメッセージの定義を使用します：

```protobuf
syntax = "proto3";
message Msg {
  optional int32 foo = 1;
}
```

クライアント B は、同じメッセージの定義を使用しますが、*存在しない* ディシプリンに従います：

```protobuf
syntax = "proto3";
message Msg {
  int32 foo = 1;
}
```

今、クライアント A がクライアントが繰り返し "同じ" メッセージを逆シリアル化および再シリアル化することで `foo` の存在を観察するシナリオを考えてみてください：

```protobuf
// Client A:
Msg m_a;
m_a.set_foo(1);                  // non-default value
assert(m_a.has_foo());           // OK
Send(m_a.SerializeAsString());   // to client B

// Client B:
Msg m_b;
m_b.ParseFromString(Receive());  // from client A
assert(m_b.foo() == 1);          // OK
Send(m_b.SerializeAsString());   // to client A

// Client A:
m_a.ParseFromString(Receive());  // from client B
assert(m_a.foo() == 1);          // OK
assert(m_a.has_foo());           // OK
m_a.set_foo(0);                  // default value
Send(m_a.SerializeAsString());   // to client B

// Client B:
Msg m_b;
m_b.ParseFromString(Receive());  // from client A
assert(m_b.foo() == 0);          // OK
Send(m_b.SerializeAsString());   // to client A

// Client A:
m_a.ParseFromString(Receive());  // from client B
assert(m_a.foo() == 0);          // OK
assert(m_a.has_foo());           // FAIL
```

クライアント A が `foo` に *明示的な存在* を依存している場合、クライアント B を経由した "ラウンドトリップ" は、クライアント A の観点から見ると損失が発生します。この例では、これは安全な変更ではありません：クライアント A は、フィールドが存在することを（`assert` によって）要求しており、API を介して何の変更もない場合でも、その要件は値およびピアに依存するケースで失敗します。

## Proto3 で *明示的な存在* を有効にする方法

これは、proto3 でフィールド追跡サポートを使用する一般的な手順です。

1. `.proto`ファイルに`optional`フィールドを追加します。
1. `protoc`を実行します（少なくともv3.15、または`--experimental_allow_proto3_optional`フラグを使用してv3.12）。
1. アプリケーションコードで生成された "hazzer"メソッドと "clear"メソッドを使用し、デフォルト値を比較または設定する代わりに。

### `.proto`ファイルの変更

これは、*存在しない*と*明示的な存在*セマンティクスに従うフィールドを持つproto3メッセージの例です：

```protobuf
syntax = "proto3";
package example;

message MyMessage {
  // No presence:
  int32 not_tracked = 1;

  // Explicit presence:
  optional int32 tracked = 2;
}
```

### `protoc`の呼び出し

proto3メッセージの存在追跡は、デフォルトで有効になっています
[v3.15.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.15.0)
リリース以降、以前は
[v3.12.0](https://github.com/protocolbuffers/protobuf/releases/tag/v3.12.0) で
`--experimental_allow_proto3_optional`フラグを使用して存在追跡を行う必要がありました。

### 生成されたコードの使用

*明示的な存在*（`optional`ラベル）を持つproto3フィールドの生成されたコードは、proto2ファイルであるかのようになります。

これは、"存在しない"例で使用される定義です：

```protobuf
syntax = "proto3";
package example;
message Msg {
  int32 foo = 1;
}
```

これは、"明示的な存在"例で使用される定義です：

```protobuf
syntax = "proto3";
package example;
message Msg {
  optional int32 foo = 1;
}
```

例では、`GetProto`関数が未指定の内容を持つ`Msg`型のメッセージを構築して返します。

#### C++の例

存在しない：

```c++
Msg m = GetProto();
if (m.foo() != 0) {
  // "Clear" the field:
  m.set_foo(0);
} else {
  // Default value: field may not have been present.
  m.set_foo(1);
}
```

明示的な存在：

```c++
Msg m = GetProto();
if (m.has_foo()) {
  // Clear the field:
  m.clear_foo();
} else {
  // Field is not present, so set it.
  m.set_foo(1);
}
```

#### C#の例

存在しない：

```c#
var m = GetProto();
if (m.Foo != 0) {
  // "Clear" the field:
  m.Foo = 0;
} else {
  // Default value: field may not have been present.
  m.Foo = 1;
}
```

明示的な存在：

```c#
var m = GetProto();
if (m.HasFoo) {
  // Clear the field:
  m.ClearFoo();
} else {
  // Field is not present, so set it.
  m.Foo = 1;
}
```

#### Goの例

存在しない：

```go
m := GetProto()
if m.Foo != 0 {
  // "Clear" the field:
  m.Foo = 0
} else {
  // Default value: field may not have been present.
  m.Foo = 1
}
```

明示的な存在：

```go
m := GetProto()
if m.Foo != nil {
  // Clear the field:
  m.Foo = nil
} else {
  // Field is not present, so set it.
  m.Foo = proto.Int32(1)
}
```

#### Javaの例

これらの例では、`Builder`を使用してクリアをデモンストレーションします。`Builder`からの存在の確認と値の取得は、メッセージタイプと同じAPIに従います。

存在しない：

```java
Msg.Builder m = GetProto().toBuilder();
if (m.getFoo() != 0) {
  // "Clear" the field:
  m.setFoo(0);
} else {
  // Default value: field may not have been present.
  m.setFoo(1);
}
```

明示的な存在：

```java
Msg.Builder m = GetProto().toBuilder();
if (m.hasFoo()) {
  // Clear the field:
  m.clearFoo()
} else {
  // Field is not present, so set it.
  m.setFoo(1);
}
```

#### Pythonの例

存在しない：

```python
m = example.Msg()
if m.foo != 0:
  # "Clear" the field:
  m.foo = 0
else:
  # Default value: field may not have been present.
  m.foo = 1
```

明示的な存在：

```python
m = example.Msg()
if m.HasField('foo'):
  # Clear the field:
  m.ClearField('foo')
else:
  # Field is not present, so set it.
  m.foo = 1
```

#### Rubyの例

存在しない場合：

```ruby
m = Msg.new
if m.foo != 0
  # "Clear" the field:
  m.foo = 0
else
  # Default value: field may not have been present.
  m.foo = 1
end
```

明示的な存在：

```ruby
m = Msg.new
if m.has_foo?
  # Clear the field:
  m.clear_foo
else
  # Field is not present, so set it.
  m.foo = 1
end
```

#### Javascriptの例

存在しない場合：

```js
var m = new Msg();
if (m.getFoo() != 0) {
  // "Clear" the field:
  m.setFoo(0);
} else {
  // Default value: field may not have been present.
  m.setFoo(1);
}
```

明示的な存在：

```js
var m = new Msg();
if (m.hasFoo()) {
  // Clear the field:
  m.clearFoo()
} else {
  // Field is not present, so set it.
  m.setFoo(1);
}
```

#### Objective-Cの例

存在しない場合：

```objective-c
Msg *m = [[Msg alloc] init];
if (m.foo != 0) {
  // "Clear" the field:
  m.foo = 0;
} else {
  // Default value: field may not have been present.
  m.foo = 1;
}
```

明示的な存在：

```objective-c
Msg *m = [[Msg alloc] init];
if (m.hasFoo()) {
  // Clear the field:
  [m clearFoo];
} else {
  // Field is not present, so set it.
  [m setFoo:1];
}
```

## チートシート {#cheat}

**Proto2:**

フィールドの存在は追跡されますか？

フィールドの種類         | 追跡されるか？
---------------------- | --------
単一フィールド         | はい
単一メッセージフィールド | はい
oneof内のフィールド     | はい
繰り返しフィールド & マップ | いいえ

**Proto3:**

フィールドの存在は追跡されますか？

フィールドの種類         | 追跡されるか？
---------------------- | ------------------------
*その他* 単一フィールド | `optional`として定義されている場合
単一メッセージフィールド | はい
oneof内のフィールド     | はい
繰り返しフィールド & マップ | いいえ

**Edition 2023:**

フィールドの存在は追跡されますか？

フィールドの種類                                         | 追跡されるか？
-------------------------------------------------- | --------
デフォルト                                            | はい
`features.field_presence`が`LEGACY_REQUIRED`に設定されている場合 | はい
`features.field_presence`が`IMPLICIT`に設定されている場合        | いいえ
繰り返しフィールド & マップ                               | いいえ
```
