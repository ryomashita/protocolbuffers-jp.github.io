## はじめに {#intro}

このページでは、拡張宣言とは何か、なぜ必要なのか、そしてどのように使用するのかについて詳しく説明します。

**注意:** 拡張宣言は主に proto2 で使用され、proto3 は現時点では拡張をサポートしていません（[カスタムオプションの宣言](/programming-guides/proto3/#customoptions)を除く）。

拡張についての導入が必要な場合は、この[拡張ガイド](https://protobuf.dev/programming-guides/proto2/#extensions)を参照してください。

## 動機 {#motivation}

拡張宣言は通常のフィールドと拡張の中間を目指しています。拡張と同様に、フィールドのメッセージ型に依存関係を作成せず、未使用のメッセージを削除することが難しいか不可能な環境では、よりスリムなビルドグラフと小さなバイナリが生成されます。通常のフィールドと同様に、フィールド名/番号は包含メッセージに表示されるため、衝突を回避し、宣言されたフィールドの便利なリストを表示するのが簡単になります。

拡張宣言で占有された拡張番号をリストアップすることで、ユーザーが利用可能な拡張番号を選択し、衝突を回避するのが簡単になります。

## 使用法 {#usage}

拡張宣言は拡張範囲のオプションです。C++の前方宣言のように、拡張フィールドのフィールドタイプ、フィールド名、および基数（単数または繰り返し）を宣言することができます。完全な拡張定義を含む `.proto` ファイルをインポートすることなく、拡張フィールドを宣言できます：

```proto
syntax = "proto2";

message Foo {
  extensions 4 to 1000 [
    declaration = {
      number: 4,
      full_name: ".my.package.event_annotations",
      type: ".logs.proto.ValidationAnnotations",
      repeated: true },
    declaration = {
      number: 999,
      full_name: ".foo.package.bar",
      type: "int32"}];
}
```

この構文には次の意味があります：

*   単一の拡張範囲内で異なる拡張番号を持つ複数の `declaration` を定義できます（範囲のサイズが許可する場合）。
*   拡張範囲に対する宣言がある場合、その範囲の *すべて* の拡張も宣言する必要があります。これにより、宣言されていない拡張が追加されるのを防ぎ、新しい拡張が範囲の宣言を使用することが強制されます。
*   指定されたメッセージ型（`.logs.proto.ValidationAnnotations`）は事前に定義されている必要はありません。別の `.proto` ファイルで定義される可能性のある有効な名前であるかどうかのみを確認します。
*   このメッセージ（`Foo`）の拡張がこの名前または番号でこのフォワード宣言と一致する番号、タイプ、および完全な名前を持つ場合、このファイルまたは他の `.proto` ファイルがこのメッセージの拡張を定義する場合、その拡張がフォワード宣言されたものと一致することを強制します。

**警告:** `extensions 4, 999` のような拡張範囲グループの宣言を避けてください。これらの宣言が適用される拡張範囲が不明確であり、現在サポートされていません。

拡張宣言は、異なるパッケージを持つ2つの拡張フィールドを期待しています：

```proto
package my.package;
extend Foo {
  repeated logs.proto.ValidationAnnotations event_annotations = 4;
}
```

```proto
package foo.package;
extend Foo {
  optional int32 bar = 999;
}
```

### 予約済み宣言 {#reserved}

拡張宣言は `reserved: true` とマークされることがあり、これはもはやアクティブに使用されておらず、拡張定義が削除されたことを示します。**拡張宣言を削除したり、`type` や `full_name` の値を編集したりしないでください**。

この `reserved` タグは、通常のフィールドのための予約キーワードとは別であり、**拡張範囲を分割する必要はありません**。

```proto {highlight="context:reserved"}
syntax = "proto2";

message Foo {
  extensions 4 to 1000 [
    declaration = {
      number: 500,
      full_name: ".my.package.event_annotations",
      type: ".logs.proto.ValidationAnnotations",
      reserved: true }];
}
```

宣言で `reserved` とされた数値を使用する拡張フィールドの定義はコンパイルに失敗します。

## descriptor.proto における表現 {#representation}

拡張宣言は、`proto2.ExtensionRangeOptions` のフィールドとして descriptor.proto に表現されます：

```proto
message ExtensionRangeOptions {
  message Declaration {
    optional int32 number = 1;
    optional string full_name = 2;
    optional string type = 3;
    optional bool reserved = 5;
    optional bool repeated = 6;
  }
  repeated Declaration declaration = 2;
}
```

## リフレクションフィールドの検索 {#reflection}

拡張宣言は通常のフィールド検索関数からは *返されません*。`Descriptor::FindFieldByName()` や `Descriptor::FindFieldByNumber()` のような関数からは返されません。拡張と同様に、拡張検索ルーチンである `DescriptorPool::FindExtensionByName()` のような方法で発見できます。これは、宣言が定義ではなく、十分な情報を持っていないため、完全な `FieldDescriptor` を返すことができないという事実を反映した明示的な選択です。

宣言された拡張は、TextFormat や JSON の観点から通常の拡張と同様に振る舞います。これは、既存のフィールドを宣言された拡張に移行する場合、そのフィールドのリフレクティブな使用を最初に移行する必要があることを意味します。

## 数値の割り当てに拡張宣言を使用する {#recommendation}

拡張は通常のフィールドと同様にフィールド番号を使用するため、各拡張には親メッセージ内で一意の番号が割り当てられることが重要です。親メッセージ内のすべての拡張のフィールド番号とタイプを宣言するために、拡張宣言を使用することをお勧めします。拡張宣言は、親メッセージのすべての拡張の登録簿として機能し、protoc はフィールド番号の競合がないことを強制します。新しい拡張を追加する際には、以前に追加された拡張番号を単純に1つ増やして番号を選択してください。拡張を削除する際には、フィールド番号を `reserved` としてマークして、誤って再利用されるリスクを排除してください。

この規約は単なる推奨事項であり、protobuf チームは誰もがそれに従うことを強制する能力や意欲を持っていません。拡張可能なメッセージに対して拡張番号を拡張宣言を通じて調整したくない場合は、他の手段を使って調整することを選択することができます。ただし、拡張番号の誤用は深刻な問題を引き起こす可能性があるため、非常に注意してください。

この問題を回避する方法の一つは、拡張機能を完全に避け、代わりに[`google.protobuf.Any`](/programming-guides/proto3/#any)を使用することです。これは、ストレージをフロントエンドとするAPIや、クライアントが proto の内容に関心を持ち、受信システムがそうでない場合に適した選択肢となるかもしれません。

### 拡張番号の再利用の影響 {#reusing}

拡張は、コンテナメッセージの外で定義されたフィールドであり、通常は別々の .proto ファイルに定義されます。この定義の分散化により、2人の開発者が同じ拡張フィールド番号の異なる定義を誤って作成することが容易になります。

拡張定義を変更することの結果は、拡張と標準フィールドの場合と同じです。フィールド番号の再利用は、proto をワイヤ形式からデコードする際に曖昧さを導入します。protobuf のワイヤ形式はシンプルであり、1つの定義でエンコードされたフィールドと別の定義でデコードされたフィールドを検出するための良い方法を提供しません。

この曖昧さは、クライアントが1つの拡張定義を使用し、サーバーが別の拡張定義を使用して通信するなど、短期間内に現れる可能性があります。

この曖昧さは、データを1つの拡張定義でエンコードして保存し、後で2番目の拡張定義を使用して取得およびデコードする場合など、より長期間にわたって現れる可能性があります。最初の拡張定義がデータをエンコードして保存した後に削除された場合、この長期的なケースは診断が難しいかもしれません。

これによる結果は次のとおりです：

1. パースエラー（最良のケース）。
2. PII / SPII の漏洩 - PII または SPII が1つの拡張定義を使用して書かれ、別の拡張定義を使用して読まれた場合。
3. データの破損 - データが「間違った」定義を使用して読み取られ、変更されて書き換えられた場合。

データ定義の曖昧さは、最低でもデバッグに時間を費やすことになるでしょう。それがデータ漏洩や破損を引き起こし、数ヶ月かかるクリーンアップを必要とする可能性もあります。

## 使用上のヒント

### 拡張宣言を削除しない {#never-delete}

拡張宣言を削除すると、将来の誤使用の可能性が生じます。拡張がもはや処理されなくなり、定義が削除された場合、拡張宣言は[予約済みとしてマーク](#reserved)される可能性があります。

### `reserved` リストからのフィールド名や番号を新しい拡張宣言に使用しない {#never-reuse-reserved}

予約された番号は、過去にフィールドや他の拡張で使用されている可能性があります。

予約されたフィールドの`full_name`を使用することはお勧めできません。textprotoを使用する際に曖昧性が生じる可能性があるためです。

### 既存の拡張宣言のタイプを変更しない {#never-change-type}

拡張フィールドのタイプを変更すると、データの破損が発生する可能性があります。

拡張フィールドが列挙型またはメッセージ型であり、その列挙型またはメッセージ型が名前変更される場合、宣言名の更新が必要であり、安全です。破損を回避するためには、タイプの更新、拡張フィールドの定義、および拡張宣言のすべてが1つのコミットで行われるべきです。

### 拡張フィールドの名前変更には注意を払う {#caution-renaming}

拡張フィールドの名前変更はワイヤーフォーマットでは問題ありませんが、JSONやTextFormatの解析を壊す可能性があります。
