+++
title = "拡張宣言"
weight = 83
description = "拡張宣言について詳細に説明し、その必要性と使用方法について説明します。"
type = "docs"
+++

<!--*
# Document freshness: For more information, see go/fresh-source.
freshness: { owner: 'shaod' reviewed: '2023-09-06' }
*-->

## はじめに {#intro}

このページでは、拡張宣言が何であり、なぜ必要なのか、そしてどのように使用するのかについて詳細に説明します。

**注意:** 拡張宣言は主にproto2で使用されており、proto3は現時点では拡張をサポートしていません（[カスタムオプションの宣言](/programming-guides/proto3/#customoptions)を除く）。

拡張についての導入が必要な場合は、この[拡張ガイド](https://protobuf.dev/programming-guides/proto2/#extensions)を参照してください。

## 動機 {#motivation}

拡張宣言は通常のフィールドと拡張の中間を目指しています。拡張のように、フィールドのメッセージタイプへの依存を作成せず、未使用のメッセージを削除することが難しいか不可能な環境では、よりスリムなビルドグラフと小さなバイナリが生成されます。通常のフィールドのように、フィールド名/番号は包含メッセージに表示され、衝突を回避し、宣言されたフィールドの便利なリストを表示するのに役立ちます。

拡張宣言で占有された拡張番号をリストアップすることで、ユーザーが利用可能な拡張番号を選択し、衝突を回避するのが容易になります。

## 使用方法 {#usage}

拡張宣言は拡張範囲のオプションです。C++の前方宣言のように、拡張フィールドのフィールドタイプ、フィールド名、および基数（単数または繰り返し）を宣言することができます。`.proto`ファイルをインポートせずに拡張定義全体を含む`.proto`ファイルを宣言できます：

```proto
syntax = "proto2";

message Foo {
  extensions 4 to 1000 [
    declaration = {
      number: 4,
      full_name: ".my.package.event_annotations",
      type: ".logs.proto.ValidationAnnotations",
      repeated: true },
    declaration = {
      number: 999,
      full_name: ".foo.package.bar",
      type: "int32"}];
}
```

この構文には以下の意味があります：

*   単一の拡張番号を持つ複数の`declaration`を、範囲のサイズが許可する場合に1つの拡張範囲で定義できます。
*   拡張範囲の宣言がある場合、その範囲の*すべて*の拡張を宣言する必要があります。これにより、宣言されていない拡張が追加されるのを防ぎ、新しい拡張が範囲の宣言を使用することが強制されます。
*   指定されたメッセージタイプ（`.logs.proto.ValidationAnnotations`）は事前に定義またはインポートされている必要はありません。別の`.proto`ファイルで定義される可能性のある有効な名前であることだけを確認します。
*   このまたは別の`.proto`ファイルがこのメッセージ（`Foo`）のこの名前または番号で拡張を定義する場合、ここで前方宣言された番号、タイプ、および完全な名前が一致することを強制します。
```

**警告:** `extensions 4, 999` のような拡張範囲グループの宣言を避けてください。宣言が適用される拡張範囲が不明確であり、現在サポートされていません。

異なるパッケージを持つ2つの拡張フィールドを期待する拡張宣言:

```proto
package my.package;
extend Foo {
  repeated logs.proto.ValidationAnnotations event_annotations = 4;
}
```

```proto
package foo.package;
extend Foo {
  optional int32 bar = 999;
}
```

### 予約宣言 {#reserved}

拡張宣言は `reserved: true` とマークされることがあり、それはもはやアクティブに使用されておらず、拡張定義が削除されたことを示します。**拡張宣言を削除したり、`type` や `full_name` の値を編集したりしないでください**。

この `reserved` タグは通常のフィールドのための `reserved` キーワードとは別であり、**拡張範囲を分割する必要はありません**。

```proto {highlight="context:reserved"}
syntax = "proto2";

message Foo {
  extensions 4 to 1000 [
    declaration = {
      number: 500,
      full_name: ".my.package.event_annotations",
      type: ".logs.proto.ValidationAnnotations",
      reserved: true }];
}
```

宣言で `reserved` とマークされた番号を使用する拡張フィールドの定義はコンパイルに失敗します。

## descriptor.proto における表現 {#representation}

拡張宣言は `proto2.ExtensionRangeOptions` のフィールドとして descriptor.proto に表現されます:

```proto
message ExtensionRangeOptions {
  message Declaration {
    optional int32 number = 1;
    optional string full_name = 2;
    optional string type = 3;
    optional bool reserved = 5;
    optional bool repeated = 6;
  }
  repeated Declaration declaration = 2;
}
```

## リフレクションフィールドの検索 {#reflection}

拡張宣言は通常のフィールド検索関数（`Descriptor::FindFieldByName()` や `Descriptor::FindFieldByNumber()`）からは*返されません*。拡張と同様に、拡張検索ルーチン（`DescriptorPool::FindExtensionByName()` など）によって発見されます。これは、宣言が定義ではなく、完全な `FieldDescriptor` を返すのに十分な情報を持っていないという事実を反映した明示的な選択です。

宣言された拡張は、TextFormat と JSON の観点から通常の拡張と同様に振る舞います。これは、既存のフィールドを宣言された拡張に移行する場合、そのフィールドのリフレクティブな使用を最初に移行する必要があることを意味します。

## 番号の割り当てに拡張宣言を使用する {#recommendation}

拡張は通常のフィールドと同様にフィールド番号を使用するため、各拡張には親メッセージ内で一意の番号が割り当てられることが重要です。親メッセージ内のすべての拡張のフィールド番号とタイプを宣言するために、拡張宣言を使用することをお勧めします。拡張宣言は、親メッセージのすべての拡張の登録簿として機能し、protoc はフィールド番号の競合がないことを強制します。新しい拡張を追加する際には、以前に追加された拡張番号を単純に1つ増やして番号を選択してください。拡張を削除する際には、フィールド番号が誤って再利用されるリスクを排除するために、その番号を `reserved` としてマークすることを確認してください。

この規約は単なる推奨事項であり、protobuf チームは拡張可能なメッセージに対してこれに従うことを強制する能力や意欲を持っていません。もし拡張可能な proto の所有者として、拡張番号を拡張宣言を通じて調整したくない場合は、他の手段を使って調整することを選択することができます。ただし、拡張番号の誤って再利用は深刻な問題を引き起こす可能性があるため、非常に注意してください。

この問題を回避する方法の一つは、拡張機能を完全に避け、代わりに[`google.protobuf.Any`](/programming-guides/proto3/#any)を使用することです。これは、ストレージをフロントエンドとする API や、クライアントが proto の内容に関心を持ち、それを受信するシステムが関心を持たないパススルーシステムに適した選択肢となるかもしれません。

### 拡張番号の再利用の結果 {#reusing}

拡張は、通常は別々の .proto ファイルで定義されたコンテナメッセージの外部に定義されたフィールドです。この定義の分散化により、2人の開発者が同じ拡張フィールド番号の異なる定義を誤って作成することが容易になります。

拡張定義を変更することの結果は、拡張と標準フィールドの場合と同じです。フィールド番号の再利用は、proto がワイヤーフォーマットからどのようにデコードされるべきかについての曖昧さを導入します。protobuf のワイヤーフォーマットはシンプルであり、異なる定義でエンコードされたフィールドを検出し、別の定義でデコードする方法を提供しません。

この曖昧さは、クライアントが1つの拡張定義を使用し、サーバーが別の定義を使用して通信するなど、短期間内に現れる可能性があります。

この曖昧さは、データを1つの拡張定義でエンコードし、後で別の拡張定義で取得してデコードするような長期的なケースでも現れる可能性があります。この長期的なケースは、データがエンコードおよび保存された後に最初の拡張定義が削除された場合、診断が難しいかもしれません。

これによる結果は次のとおりです：

1. パースエラー（最良のケース）。
2. PII / SPII の漏洩 - PII または SPII が1つの拡張定義を使用して書き込まれ、別の拡張定義を使用して読み取られる場合。
3. データの破損 - データが「間違った」定義を使用して読み取られ、変更されて書き換えられる場合。

データ定義の曖昧さは、最低でもデバッグに時間を費やすことになるでしょう。さらに、データリークや破損が発生し、それをクリーンアップするのに数ヶ月かかる可能性もあります。

## 使用上の注意

### 拡張宣言を削除しない {#never-delete}

拡張宣言を削除すると、将来の誤った再利用の可能性が生じます。拡張がもはや処理されなくなり、定義が削除された場合、拡張宣言は[予約済みとしてマーク](#reserved)される可能性があります。

### `reserved` リストからのフィールド名または番号を新しい拡張宣言に再利用しない {#never-reuse-reserved}

予約された番号は、過去にフィールドや他の拡張で使用されている可能性があります。

予約されたフィールドの`full_name`を使用することはお勧めできません。textprotoを使用する際に曖昧性が生じる可能性があるためです。

### 既存の拡張宣言のタイプを変更しない {#never-change-type}

拡張フィールドのタイプを変更すると、データの破損が発生する可能性があります。

拡張フィールドが列挙型またはメッセージ型であり、その列挙型またはメッセージ型が名前変更される場合、宣言名の更新が必要であり、安全です。破損を回避するためには、タイプの更新、拡張フィールドの定義、拡張宣言のすべてを1つのコミットで行うべきです。

### 拡張フィールドの名前変更には注意 {#caution-renaming}

拡張フィールドの名前変更はワイヤーフォーマットでは問題ありませんが、JSONやTextFormatの解析を壊す可能性があります。
