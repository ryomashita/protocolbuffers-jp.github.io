+++
title = "Protoシリアライゼーションは正準ではありません"
weight = 88
description = "シリアライゼーションの動作となぜ正準ではないかを説明します。"
type = "docs"
+++

<!--*
# ドキュメントの新鮮さ: 詳細については、go/fresh-source を参照してください。
新鮮さ: { owner: 'haberman' reviewed: '2024-02-05' }
*-->

多くの人々は、シリアライズされたprotoがそのprotoの内容を正準に表現することを望んでいます。使用例には次のものがあります:

*   シリアライズされたprotoをハッシュテーブルのキーとして使用する
*   シリアライズされたprotoのフィンガープリントやチェックサムを取る
*   メッセージの等価性を確認する手段として、シリアライズされたペイロードを比較する

残念ながら、*protobufのシリアライゼーションは（かつてもなく、できない）正準ではありません*。MapReduceなどの注目すべき例外はいくつかありますが、一般的にはprotoのシリアライゼーションを不安定と考えるべきです。このページではその理由を説明します。

## 決定論的は正準ではない

決定論的なシリアライゼーションは正準ではありません。シリアライザは、次のようなさまざまな理由により異なる出力を生成することがあります:

1.  protobufスキーマがいかなる方法でも変更された場合。
1.  構築中のアプリケーションがいかなる方法でも変更された場合。
1.  バイナリが異なるフラグ（例: opt vs. debug）でビルドされた場合。
1.  protobufライブラリが更新された場合。

これは、シリアライズされたprotoのハッシュが壊れやすく、時間や空間を超えて安定していないことを意味します。

シリアライズされた出力が変わる理由はさまざまあります。上記のリストはすべてを網羅しているわけではありません。いくつかは、問題領域に固有の難しさであり、正準なシリアライゼーションを保証することが非効率的または不可能になる可能性があるものです。他のものは、最適化の機会を許すために意図的に未定義のままにしているものです。

## 安定したシリアライゼーションへの固有の障壁

Protobufオブジェクトは、前方および後方互換性を提供するために未知のフィールドを保持します。未知のフィールドは正準にシリアライズできません:

1.  未知のフィールドは、バイトとサブメッセージを区別できません。両方とも同じワイヤータイプを持っています。これにより、未知のフィールドに格納されたメッセージを正準にシリアライズすることは不可能です。正準化する場合、未知のサブメッセージに再帰してフィールド番号でソートする必要がありますが、これを行うための十分な情報がありません。
1.  未知のフィールドは、効率のために常に既知のフィールドの後にシリアライズされます。しかし、正準なシリアライゼーションには、未知のフィールドをフィールド番号で既知のフィールドと交互に挿入する必要があります。これにより、その機能を使用していない人々にも効率とコードサイズのオーバーヘッドが発生します。

## 意図的に未定義とした事柄

正準シリアル化が可能であったとしても（つまり、未知のフィールド問題を解決できる場合でも）、より多くの最適化の機会を許すために、意図的にシリアル化順序を未定義のままにしています。

1. バイナリでフィールドが使用されていないことを証明できれば、スキーマから完全に削除し、未知のフィールドとして処理することができます。これにより、コードサイズとCPUサイクルを大幅に節約できます。
2. 同じフィールドのベクトルを一緒にシリアル化することで最適化の機会があるかもしれませんが、これはフィールド番号の順序を壊すことになります。

このような最適化の余地を残すために、いくつかの構成で意図的にフィールドの順序を入れ替え、アプリケーションがフィールドの順序に適切に依存しないようにします。
