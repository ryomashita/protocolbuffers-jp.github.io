このドキュメントでは、プロトコルバッファの*ワイヤーフォーマット*について説明します。これは、メッセージがワイヤー上で送信される方法やディスク上でどれだけのスペースを消費するかの詳細を定義しています。アプリケーションでプロトコルバッファを使用する際には、これを理解する必要はないかもしれませんが、最適化を行う際には有用な情報です。

すでに概念を理解しているが、参照資料が必要な場合は、[簡略化されたリファレンスカード](#cheat-sheet)セクションにスキップしてください。

[Protoscope](https://github.com/protocolbuffers/protoscope)は、低レベルのワイヤーフォーマットのスニペットを記述するための非常にシンプルな言語であり、さまざまなメッセージのエンコーディングの視覚的な参照を提供するために使用されます。 Protoscopeの構文は、それぞれが特定のバイトシーケンスにエンコードされる一連の*トークン*で構成されています。

たとえば、バッククォートは`` `70726f746f6275660a` ``のような生の16進数リテラルを示します。これは、リテラル内の16進数で示される正確なバイトにエンコードされます。引用符はUTF-8文字列を示し、`"Hello, Protobuf!"`のようなものです。このリテラルは`` `48656c6c6f2c2050726f746f62756621` ``と同義です（これはASCIIバイトで構成されていることに注意してください）。ワイヤーフォーマットの側面について議論する際に、Protoscope言語のさらなる紹介を行います。

Protoscopeツールは、エンコードされたプロトコルバッファをテキストとしてダンプすることもできます。例については、https://github.com/protocolbuffers/protoscope/tree/main/testdata を参照してください。

## 単純なメッセージ {#simple}

次の非常に単純なメッセージ定義があるとします：

```proto
message Test1 {
  optional int32 a = 1;
}
```

アプリケーションで、`Test1`メッセージを作成し、`a`を150に設定します。その後、メッセージを出力ストリームにシリアライズします。エンコードされたメッセージを調べることができた場合、3つのバイトが表示されます：

```proto
08 96 01
```

これまでのところ、小さくて数値的ですが、これは何を意味するのでしょうか？ Protoscopeツールを使用してこれらのバイトをダンプすると、`1: 150`のようなものが表示されます。これがメッセージの内容であることをどのように知るのでしょうか？

## Base 128 Varints {#varints}

可変幅整数、または*varints*はワイヤーフォーマットの中心にあります。これにより、1から10バイトの間で符号なし64ビット整数をエンコードでき、小さな値はより少ないバイトを使用します。

varint内の各バイトには、その後に続くバイトがvarintの一部であるかどうかを示す*継続ビット*があります。これはバイトの*最上位ビット*（MSB）です（時々*符号ビット*とも呼ばれます）。下位7ビットはペイロードであり、結果の整数は、構成バイトの7ビットのペイロードを連結して構築されます。

例えば、ここに数字1があります。 `` `01` ``とエンコードされています--これは1バイトなので、MSBは設定されていません：

```proto
0000 0001
^ msb
```

そして、ここに150があります。 `` `9601` ``とエンコードされています--これはもう少し複雑です：

```proto
10010110 00000001
^ msb    ^ msb
```

これが150であることをどのように理解しますか？まず、各バイトからMSBを削除します。これは単に数値の終わりに達したかどうかを示すために存在しているだけです（最初のバイトに設定されていることがわかります。varintに複数のバイトがあるため）。これらの7ビットのペイロードはリトルエンディアン順になっています。ビッグエンディアン順に変換し、連結して符号なし64ビット整数として解釈します：

```proto
10010110 00000001        // Original inputs.
 0010110  0000001        // Drop continuation bits.
 0000001  0010110        // Convert to big-endian.
   00000010010110        // Concatenate.
 128 + 16 + 4 + 2 = 150  // Interpret as an unsigned 64-bit integer.
```

プロトコルバッファにとってvarintsが非常に重要であるため、プロトスコープ構文では、これらを単純な整数として参照します。 `150`は `` `9601` ``と同じです。

## メッセージ構造 {#structure}

プロトコルバッファメッセージはキーと値のペアのシリーズです。メッセージのバイナリバージョンでは、各フィールドの番号がキーとして使用されます--各フィールドの名前と宣言されたタイプは、デコーディングエンドでのみ、メッセージタイプの定義（つまり`.proto`ファイル）を参照することで決定できます。プロトスコープはこの情報にアクセスできないため、フィールド番号のみを提供できます。

メッセージがエンコードされると、各キーと値のペアは、フィールド番号、ワイヤータイプ、およびペイロードから構成される*レコード*に変換されます。ワイヤータイプは、その後に続くペイロードの大きさをパーサーに伝えます。これにより、古いパーサーが理解できない新しいフィールドをスキップできます。このタイプのスキームは、[Tag-Length-Value](https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value)またはTLVと呼ばれることがあります。

存在するワイヤータイプは6つあります：`VARINT`、`I64`、`LEN`、`SGROUP`、`EGROUP`、`I32`

ID  | 名前   | 用途
--- | ------ | --------------------------------------------------------
0   | VARINT | int32、int64、uint32、uint64、sint32、sint64、bool、enum
1   | I64    | fixed64、sfixed64、double
2   | LEN    | string、bytes、埋め込まれたメッセージ、繰り返しフィールドのパック
3   | SGROUP | グループ開始（非推奨）
4   | EGROUP | グループ終了（非推奨）
5   | I32    | fixed32、sfixed32、float

レコードの「タグ」は、フィールド番号とワイヤータイプから構成される varint としてエンコードされます。具体的には、式 `(field_number << 3) | wire_type` によって形成されます。言い換えると、フィールドを表す varint をデコードした後、下位 3 ビットがワイヤータイプを示し、整数の残りの部分がフィールド番号を示します。

さて、簡単な例をもう一度見てみましょう。今度は、ストリーム内の最初の数値が常に varint キーであることを知っています。ここでは、`` `08` `` または（MSB を削除して）：

```proto
000 1000
```

最後の 3 ビットを取得してワイヤータイプ（0）を取得し、その後 3 ビット右にシフトしてフィールド番号（1）を取得します。Protoscope では、タグを整数に続いてコロンとワイヤータイプで表現します。したがって、上記のバイトを `1:VARINT` と書くことができます。

ワイヤータイプが 0 または `VARINT` であるため、ペイロードを取得するために varint をデコードする必要があることがわかります。上記で見たように、バイト `` `9601` `` は varint デコードして 150 になり、私たちのレコードを取得します。Protoscope では、`1:VARINT 150` として書くことができます。

Protoscope は、`:` の後に空白がある場合、タグの型を推測できます。次のトークンを先読みして、意図した内容を推測します（詳細なルールは [Protoscope's language.txt](https://github.com/protocolbuffers/protoscope/blob/main/language.txt) に詳細に記載されています）。たとえば、`1: 150` では、未型指定のタグの直後に varint があるため、Protoscope はその型を `VARINT` と推測します。`2: {}` を書いた場合、`{` を見て `LEN` と推測し、`3: 5i32` を書いた場合は `I32` と推測します。

## さらなる整数型 {#int-types}

### Bools と Enums {#bools-and-enums}

Boolsとenumsは両方とも`int32`としてエンコードされます。特にBoolsは、常に`` `00` ``または`` `01` ``としてエンコードされます。Protoscopeでは、`false`と`true`はこれらのバイト文字列のエイリアスです。

### 符号付き整数 {#signed-ints}

前のセクションで見たように、ワイヤータイプ0に関連付けられたすべてのプロトコルバッファタイプはvarintsとしてエンコードされます。ただし、varintsは符号なしですので、`sint32`および`sint64`と`int32`または`int64`のような異なる符号付きタイプは、負の整数を異なる方法でエンコードします。

`intN`タイプは、負の数を2の補数としてエンコードします。これは、符号なしの64ビット整数として、最上位ビットが設定されていることを意味します。その結果、これは*すべての10バイト*を使用する必要があることを意味します。たとえば、`-2`は、protoscopeによって次のように変換されます

```proto
11111110 11111111 11111111 11111111 11111111
11111111 11111111 11111111 11111111 00000001
```

これは、2の*2の補数*であり、符号なし算術で定義される`~0 - 2 + 1`であり、`~0`がすべて1の64ビット整数であることを意味します。これがなぜこれほど多くの1を生成するのかを理解するのは有益な練習です。

<!-- mdformat off(アスタリスクは箇条書きを引き起こす) -->
`sintN`は、負の整数をエンコードするために2の補数の代わりに「ZigZag」エンコーディングを使用します。正の整数`p`は`2 * p`（偶数）としてエンコードされ、負の整数`n`は`2 * |n| - 1`（奇数）としてエンコードされます。このエンコーディングは、正の数と負の数の間を「ジグザグ」します。たとえば：
<!-- mdformat on -->

符号つき元の数 | エンコードされた値
--------------- | ----------
0               | 0
-1              | 1
1               | 2
-2              | 3
...             | ...
0x7fffffff      | 0xfffffffe
-0x80000000     | 0xffffffff

つまり、各値`n`は次のようにエンコードされます

```
(n << 1) ^ (n >> 31)
```

`sint32`の場合、または

```
(n << 1) ^ (n >> 63)
```

64ビットバージョンの場合。

`sint32`または`sint64`が解析されると、その値は元の符号付きバージョンにデコードされます。

protoscopeでは、整数に`z`を付けるとZigZagとしてエンコードされます。たとえば、`-500z`はvarint `999`と同じです。

### 非可変長数値 {#non-varints}

非可変長数値型はシンプルです。`double` と `fixed64` はワイヤータイプ `I64` を持ち、これはパーサーに固定の8バイトのデータを期待することを伝えます。`double` レコードは `5: 25.4` と書くことで指定できますし、`fixed64` レコードは `6: 200i64` と書くことで指定できます。どちらの場合も、明示的なワイヤータイプを省略すると `I64` ワイヤータイプが適用されます。

同様に、`float` と `fixed32` はワイヤータイプ `I32` を持ち、4バイトのデータを期待することを示します。これらの構文は `i32` 接頭辞を追加することで表されます。`25.4i32` は4バイトを生成し、`200i32` も同様です。タグのタイプは `I32` と推論されます。

## 長さ指定レコード {#length-types}

*長さプレフィックス* はワイヤーフォーマットにおけるもう一つの重要な概念です。`LEN` ワイヤータイプは、タグの直後に即座に指定される可変長の長さを持ち、通常のペイロードが続きます。

次のメッセージスキーマを考えてみましょう：

```proto
message Test2 {
  optional string b = 2;
}
```

フィールド `b` のレコードは文字列であり、文字列は `LEN` でエンコードされます。もし `b` を `"testing"` に設定した場合、ASCII文字列 `"testing"` を含むフィールド番号2の `LEN` レコードとしてエンコードされます。結果は `` `120774657374696e67` `` です。バイトを分割すると、

```proto
12 07 [74 65 73 74 69 6e 67]
```

タグである `` `12` `` は `00010 010` または `2:LEN` を表し、その後に続くバイトは int32 の可変長 `7` であり、次の7バイトは `"testing"` の UTF-8 エンコーディングです。int32 の可変長は、文字列の最大長さが2GBであることを意味します。

Protoscopeでは、これは `2:LEN 7 "testing"` と書かれます。しかし、文字列の長さを繰り返すのは不便かもしれません（Protoscopeテキストでは既に引用符で囲まれています）。Protoscopeコンテンツを中括弧で囲むと、それに対して長さプレフィックスが生成されます：`{"testing"}` は `7 "testing"` の省略形です。`{}` は常にフィールドによって `LEN` レコードと推論されるため、このレコードは単純に `2: {"testing"}` と書くことができます。

`bytes` フィールドも同様にエンコードされます。

### サブメッセージ {#embedded}

サブメッセージフィールドも `LEN` ワイヤータイプを使用します。以下は、元の例メッセージ `Test1` の埋め込まれたメッセージを持つメッセージ定義です：

```proto
message Test3 {
  optional Test1 c = 3;
}
```

もし `Test1` の `a` フィールド（つまり、`Test3` の `c.a` フィールド）が 150 に設定されている場合、我々は `1a03089601` を得ます。分解すると：

```proto
 1a 03 [08 96 01]
```

最後の3バイト（`[]` 内）は、まさに私たちの[最初の例](#simple)からのものです。これらのバイトは `LEN` 型のタグに続き、長さ3、まさに文字列がエンコードされる方法と同じです。

Protoscope では、サブメッセージは非常に簡潔です。`1a03089601` は `3: {1: 150}` と書くことができます。

## Optional and Repeated Elements {#optional}

欠落している `optional` フィールドは簡単にエンコードできます：存在しない場合はレコードを省略します。これは、わずかなフィールドが設定された「巨大な」プロトはかなり疎です。

`repeated` フィールドは少し複雑です。通常の（[packed](#packed)でない）repeated フィールドは、フィールドの各要素ごとに1つのレコードを発行します。したがって、次のような場合、

```proto
message Test4 {
  optional string d = 4;
  repeated int32 e = 5;
}
```

`d` が `"hello"` に設定され、`e` が `1`、`2`、`3` に設定された `Test4` メッセージを構築すると、これは `` `220568656c6c6f280128022803` `` としてエンコードされるか、Protoscope で書かれるかもしれません。

```proto
4: {"hello"}
5: 1
5: 2
5: 3
```

ただし、`e` のレコードは連続して表示する必要はなく、他のフィールドと交互に配置することができます。同じフィールドのレコード同士の順序だけが保持されます。したがって、これは次のようにエンコードされる可能性があります

```proto
5: 1
5: 2
4: {"hello"}
5: 3
```

### Oneofs {#oneofs}

[`Oneof` フィールド](/programming-guides/proto2#oneof) は、`oneof` 内のフィールドであるかのようにエンコードされます。`oneof` に適用されるルールは、ワイヤ上でどのように表現されているかには独立して適用されます。

### Last One Wins {#last-one-wins}

通常、エンコードされたメッセージには非 `repeated` フィールドの複数のインスタンスが含まれることはありません。ただし、パーサーはそれが含まれる場合に対処することが期待されています。数値型と文字列の場合、同じフィールドが複数回現れる場合、パーサーは見た*最後の*値を受け入れます。埋め込みメッセージフィールドの場合、パーサーは同じフィールドの複数のインスタンスをマージします。これらのルールの効果は、2つのエンコードされたメッセージの連結を解析すると、2つのメッセージを別々に解析して生成されたオブジェクトをマージしたかのような結果が得られることです。つまり、これは:

```cpp
MyMessage message;
message.ParseFromString(str1 + str2);
```

は、次のように等価です：

```cpp
MyMessage message, message2;
message.ParseFromString(str1);
message2.ParseFromString(str2);
message.MergeFrom(message2);
```

このプロパティは時折便利であり、タイプがわからなくても2つのメッセージを（連結して）マージできるようにします。

### パックされた繰り返しフィールド {#packed}

v2.1.0から、プリミティブ型の `repeated` フィールド（`string` または `bytes` でない任意の[スカラー型](/programming-guides/proto2#scalar)）を「パックされた」状態で宣言できます。proto2 では、これはフィールドオプション `[packed=true]` を使用して行われます。proto3 ではデフォルトです。

1つのエントリごとに1つのレコードとしてエンコードされる代わりに、それらは各要素が連結された単一の `LEN` レコードとしてエンコードされます。デコードする際は、要素が `LEN` レコードから1つずつデコードされ、ペイロードが尽きるまで続きます。次の要素の開始位置は、前の要素の長さによって決定され、それ自体はフィールドのタイプに依存します。

例えば、次のメッセージ型があるとします：

```proto
message Test5 {
  repeated int32 f = 6 [packed=true];
}
```

今、`Test5` を構築し、繰り返しフィールド `f` に値 3、270、86942 を提供したとします。エンコードすると、`` `3206038e029ea705` `` となり、Protoscope テキストでは次のようになります：

```proto
6: {3 270 86942}
```

「パックされた」状態にできるのは、プリミティブ数値型の繰り返しフィールドのみです。これらは通常、`VARINT`、`I32`、または `I64` ワイヤータイプを使用するタイプです。

パックされた繰り返しフィールドに複数のキーと値のペアをエンコードする理由は通常ありませんが、パーサーは複数のキーと値のペアを受け入れる準備をしている必要があります。この場合、ペイロードは連結される必要があります。各ペアは要素の整数倍を含んでいる必要があります。次は、パーサーが受け入れる必要がある同じメッセージの有効なエンコーディングです：

```proto
6: {3 270}
6: {86942}
```

プロトコルバッファパーサーは、`packed` としてコンパイルされた繰り返しフィールドを、パックされていないかのように解析できるようにする必要があります。これにより、既存のフィールドに `[packed=true]` を追加することが、前方および後方互換性のある方法で可能になります。

### マップ {#maps}

Mapフィールドは、特別な種類の繰り返しフィールドの省略形です。以下のような場合、

```proto
message Test6 {
  map<string, int32> g = 7;
}
```

実際には次のようになります

```proto
message Test6 {
  message g_Entry {
    optional string key = 1;
    optional int32 value = 2;
  }
  repeated g_Entry g = 7;
}
```

したがって、マップは、2つのフィールドを持つ`LEN`型のレコードのシーケンスとして、`repeated`メッセージフィールドとまったく同じようにエンコードされます。

## グループ {#groups}

グループは使用されるべきでない非推奨の機能ですが、ワイヤーフォーマットには残っており、一言で触れる価値があります。

グループはサブメッセージのようなものですが、`LEN`プレフィックスではなく特別なタグで区切られています。メッセージ内の各グループにはフィールド番号があり、これらの特別なタグで使用されます。

フィールド番号`8`のグループは`8:SGROUP`タグで始まります。`SGROUP`レコードには空のペイロードがあり、これによりグループの開始が示されます。グループ内のすべてのフィールドがリストされた後、対応する`8:EGROUP`タグがその終わりを示します。`EGROUP`レコードにもペイロードがないため、`8:EGROUP`は完全なレコードです。グループのフィールド番号は一致する必要があります。`8:EGROUP`が期待される場所で`7:EGROUP`が発生した場合、メッセージは不正な形式です。

Protoscopeはグループを書くための便利な構文を提供します。次のように書く代わりに

```proto
8:SGROUP
  1: 2
  3: {"foo"}
8:EGROUP
```

Protoscopeでは次のように書くことができます

```proto
8: !{
  1: 2
  3: {"foo"}
}
```

これにより、適切な開始および終了グループマーカーが生成されます。`!{}`構文は、`8:`のような未入力のタグ式の直後にのみ発生できます。

## フィールドの順序 {#order}

フィールド番号は`.proto`ファイル内で任意の順序で宣言される可能性があります。選択された順序は、メッセージがシリアライズされる方法に影響を与えません。

メッセージがシリアライズされるとき、既知のフィールドまたは[未知のフィールド](/programming-guides/proto2#updating)がどのように書き込まれるかについては保証されません。シリアル化の順序は実装の詳細であり、特定の実装の詳細は将来変更される可能性があります。したがって、プロトコルバッファパーサは、フィールドを任意の順序で解析できる必要があります。

### 影響 {#implications}

*   シリアル化されたメッセージのバイト出力が安定しているとは限りません。これは特に、他のシリアル化されたプロトコルバッファメッセージを表すトランジティブバイトフィールドを持つメッセージの場合に当てはまります。
*   デフォルトでは、同じプロトコルバッファメッセージインスタンスに対するシリアル化メソッドの繰り返し呼び出しは、同じバイト出力を生成しない場合があります。つまり、デフォルトのシリアル化は決定論的ではありません。
    *   決定論的シリアル化は、特定のバイナリに対して同じバイト出力を保証します。バイト出力は、バイナリの異なるバージョン間で変更する可能性があります。
*   プロトコルバッファメッセージインスタンス`foo`に対して次のチェックが失敗する可能性があります：
    *   `foo.SerializeAsString() == foo.SerializeAsString()`
    *   `Hash(foo.SerializeAsString()) == Hash(foo.SerializeAsString())`
    *   `CRC(foo.SerializeAsString()) == CRC(foo.SerializeAsString())`
    *   `FingerPrint(foo.SerializeAsString()) == FingerPrint(foo.SerializeAsString())`
*   論理的に等価なプロトコルバッファメッセージ`foo`と`bar`が異なるバイト出力にシリアル化される可能性があるいくつかの例のシナリオは次のとおりです：
    *   `bar`は、一部のフィールドを未知として扱う古いサーバーによってシリアル化されています。
    *   `bar`は、異なるプログラミング言語で実装されたサーバーによってシリアル化され、フィールドが異なる順序でシリアル化されています。
    *   `bar`には、決定論的でない方法でシリアル化されるフィールドがあります。
    *   `bar`には、異なる方法でシリアル化されるプロトコルバッファメッセージのシリアル化バイト出力を格納するフィールドがあります。
    *   `bar`は、実装の変更により異なる順序でフィールドをシリアル化する新しいサーバーによってシリアル化されています。
    *   `foo`と`bar`は、異なる順序で個々のメッセージの連結です。

## エンコードされた Proto のサイズ制限 {#size-limit}

Proto はシリアライズされたときに 2 GiB より小さくなければなりません。多くの Proto 実装は、この制限を超えるメッセージをシリアライズまたは解析することを拒否します。

## コンデンスド リファレンス カード {#cheat-sheet}

以下は、ワイヤ形式の最も顕著な部分を簡単に参照できる形式で提供します。

```none
message    := (tag value)*

tag        := (field << 3) bit-or wire_type;
                encoded as uint32 varint
value      := varint      for wire_type == VARINT,
              i32         for wire_type == I32,
              i64         for wire_type == I64,
              len-prefix  for wire_type == LEN,
              <empty>     for wire_type == SGROUP or EGROUP

varint     := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64;
                encoded as varints (sintN are ZigZag-encoded first)
i32        := sfixed32 | fixed32 | float;
                encoded as 4-byte little-endian;
                memcpy of the equivalent C types (u?int32_t, float)
i64        := sfixed64 | fixed64 | double;
                encoded as 8-byte little-endian;
                memcpy of the equivalent C types (u?int64_t, double)

len-prefix := size (message | string | bytes | packed);
                size encoded as int32 varint
string     := valid UTF-8 string (e.g. ASCII);
                max 2GB of bytes
bytes      := any sequence of 8-bit bytes;
                max 2GB of bytes
packed     := varint* | i32* | i64*,
                consecutive values of the type specified in `.proto`
```

また、[Protoscope 言語リファレンス](https://github.com/protocolbuffers/protoscope/blob/main/language.txt) も参照してください。

### キー {#cheat-sheet-key}

`message   := (tag value)*`
:   メッセージは、タグと値のペアのゼロ個以上のシーケンスとしてエンコードされます。

`tag        := (field << 3) bit-or wire_type`
:   タグは、最下位 3 ビットに格納された `wire_type` と、`.proto` ファイルで定義されたフィールド番号の組み合わせです。

`value      := varint   for wire_type == VARINT, ...`
:   値は、タグで指定された `wire_type` に応じて異なる方法で格納されます。

`varint     := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64`
:   リストされたデータ型のいずれかを格納するために varint を使用できます。

`i32        := sfixed32 | fixed32 | float`
:   リストされたデータ型のいずれかを格納するために fixed32 を使用できます。

`i64        := sfixed64 | fixed64 | double`
:   リストされたデータ型のいずれかを格納するために fixed64 を使用できます。

`len-prefix := size (message | string | bytes | packed)`
:   長さ接頭辞付きの値は、長さ（varint としてエンコードされた）と、その後にリストされたデータ型のいずれかが格納されます。

`string     := valid UTF-8 string (e.g. ASCII)`
:   記述されているように、文字列は UTF-8 文字エンコーディングを使用する必要があります。文字列は 2GB を超えることはできません。

`bytes      := any sequence of 8-bit bytes`
:   記述されているように、バイトはカスタムデータ型を格納でき、最大 2GB のサイズまでです。

`packed     := varint* | i32* | i64*`
:   プロトコル定義で説明されているタイプの連続した値を格納する場合は、`packed` データ型を使用します。最初の値以降の値にはタグが削除され、フィールドごとではなく要素ごとにタグのコストが均等化されます。

Please provide the Markdown content you would like me to translate into Japanese.
