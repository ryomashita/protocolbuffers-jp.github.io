+++
title = "C++ アリーナ割り当てガイド"
weight = 520
linkTitle = "アリーナ割り当てガイド"
description = "アリーナ割り当ては、プロトコルバッファを使用する際にメモリ使用量を最適化し、パフォーマンスを向上させるための C++ 専用機能です。"
type = "docs"
+++

このページでは、アリーナ割り当てが有効になっている場合に、プロトコルバッファコンパイラが生成する C++ コードについて詳しく説明します。これは、[C++ 生成コードガイド](/reference/cpp/cpp-generated)で説明されているコードに加えて生成されるものです。アリーナ割り当てが有効になっていることを前提としています。[言語ガイド](/programming-guides/proto2)および[C++ 生成コードガイド](/reference/cpp/cpp-generated)の内容に精通していることを前提としています。

## アリーナ割り当てを使用する理由 {#why}

メモリの割り当てと解放は、プロトコルバッファコードで消費される CPU 時間の大部分を占めています。デフォルトでは、プロトコルバッファは各メッセージオブジェクト、そのサブオブジェクト、および文字列などのいくつかのフィールドタイプのためにヒープ割り当てを実行します。これらの割り当ては、メッセージの解析時やメモリ内で新しいメッセージを構築する際に一括して発生し、メッセージとそのサブオブジェクトツリーが解放される際に関連する解放が行われます。

アリーナベースの割り当ては、このパフォーマンスコストを削減するために設計されています。アリーナ割り当てでは、新しいオブジェクトはアリーナと呼ばれる事前に大きな塊で割り当てられたメモリから割り当てられます。オブジェクトは、アリーナ全体を破棄することで一括して解放でき、理想的には含まれるオブジェクトのデストラクタを実行せずに済みます（ただし、必要に応じてアリーナは「デストラクタリスト」を維持することができます）。これにより、オブジェクトの割り当てが単純なポインタの増分にまで簡素化され、解放はほぼ無料になります。アリーナ割り当ては、キャッシュ効率も向上させます。メッセージが解析される際、連続したメモリに割り当てられる可能性が高くなり、メッセージのトラバースがホットキャッシュラインにヒットする可能性が高くなります。

これらの利点を得るには、オブジェクトの寿命を把握し、アリーナを使用する適切な粒度を見つける必要があります（サーバーの場合、これは通常、リクエストごとです）。アリーナ割り当てから最大の効果を得る方法については、[使用パターンとベストプラクティス](#usage)で詳細を確認できます。

この表は、アリーナを使用する場合の典型的なパフォーマンスの利点と欠点を要約しています：

操作                 | ヒープに割り当てられたプロトメッセージ                                                                                     | アリーナに割り当てられたプロトメッセージ
:-------------------- | :--------------------------------------------------------------------------------------------------------------------------- | :-----------------------------
*メッセージの割り当て* | 平均的に遅い                                                                                                                | 平均的に速い
*メッセージの破棄*   | 平均的に遅い                                                                                                                | 平均的に速い
*メッセージの移動*   | 常に移動（コストとしては[浅いコピー](https://en.wikipedia.org/wiki/Object_copying#Shallow_copy)に相当） | 時々[深いコピー](https://en.wikipedia.org/wiki/Object_copying#Deep_copy)

## はじめに {#gettingstarted}

プロトコルバッファコンパイラは、ファイル内のメッセージのアリーナ割り当てのためのコードを生成します。以下の例で使用されています。

```cpp
#include <google/protobuf/arena.h>
{
  google::protobuf::Arena arena;
  MyMessage* message = google::protobuf::Arena::CreateMessage<MyMessage>(&arena);
  // ...
}
```

`CreateMessage()` によって作成されたメッセージオブジェクトは、`arena` が存在する限り存在し、返されたメッセージポインタを `delete` してはいけません。メッセージオブジェクトの内部ストレージ（一部の例外[^1]を除く）およびサブメッセージ（たとえば、`MyMessage` 内の繰り返しフィールド内のサブメッセージ）もアリーナ上に割り当てられます。

ほとんどの場合、アリーナ割り当てを使用していない場合と同じように、コードの残りの部分は同じになります。

アリーナ APIについて詳しく見ていき、文書の最後により詳細な[例](#example)をご覧いただけます。

[^1]: 現在、文字列フィールドは、含まれるメッセージがアリーナ上にある場合でも、データをヒープに格納します。未知のフィールドもヒープに割り当てられます。

## Arena クラス API {#arenaclass}

[`google::protobuf::Arena`](/reference/cpp/api-docs/google.protobuf.arena.md) クラスを使用してアリーナ上にメッセージオブジェクトを作成します。このクラスは以下のパブリックメソッドを実装しています。

### コンストラクタ {#constructors}

-   `Arena()`: デフォルトのパラメータで新しいアリーナを作成し、平均的な使用ケースに調整します。

-   `Arena(const ArenaOptions& options)`: 指定された割り当てオプションを使用する新しいアリーナを作成します。`ArenaOptions`で利用可能なオプションには、割り当て前にユーザー提供のメモリの初期ブロックを使用する能力、メモリブロックの初期および最大要求サイズを制御する能力、カスタムブロック割り当ておよび解放関数ポインタを渡して、ブロックの上にフリーリストなどを構築する能力が含まれています。

### 割り当てメソッド {#allocation}

-   `template<typename T> static T* CreateMessage(Arena* arena)`: メッセージタイプ`T`の新しいプロトコルバッファオブジェクトをアリーナ上に作成します。

    `arena`がNULLでない場合、返されるメッセージオブジェクトはアリーナ上に割り当てられ、その内部ストレージおよびサブメッセージ（ある場合）も同じアリーナ上に割り当てられ、その寿命はアリーナの寿命と同じです。オブジェクトは手動で削除/解放してはいけません。アリーナがメッセージオブジェクトを所有しています。

    `arena`がNULLの場合、返されるメッセージオブジェクトはヒープ上に割り当てられ、呼び出し元がオブジェクトを所有します。

-   `template<typename T> static T* Create(Arena* arena, args...)`: `CreateMessage()`と似ていますが、プロトコルバッファメッセージタイプだけでなく、任意のクラスのオブジェクトをアリーナ上に作成できます。たとえば、このC++クラスがあるとします:

    ```cpp
    class MyCustomClass {
        MyCustomClass(int arg1, int arg2);
        // ...
    };
    ```

    ...次のようにしてアリーナ上にそのインスタンスを作成できます:

    ```cpp
    void func() {
        // ...
        google::protobuf::Arena arena;
        MyCustomClass* c = google::protobuf::Arena::Create<MyCustomClass>(&arena, constructor_arg1, constructor_arg2);
        // ...
    }
    ```

-   `template<typename T> static T* CreateArray(Arena* arena, size_t n)`: `arena`がNULLでない場合、このメソッドは`T`型の`n`要素のための生のストレージを割り当てて返します。アリーナが返されたメモリを所有し、破棄時に解放します。`arena`がNULLの場合、このメソッドはヒープ上にストレージを割り当て、呼び出し元が所有権を受け取ります。

    `T`はトリビアルなコンストラクタを持たなければなりません：配列がアリーナ上で作成される際にコンストラクタは呼び出されません。

### "所有リスト" メソッド {#owned-list}

以下のメソッドは、特定のオブジェクトやデストラクタがアリーナによって「所有」され、アリーナ自体が削除されるときにそれらが削除または呼び出されることを保証します。

-   `template<typename T> void Own(T* object)`: `object`をアリーナの所有するヒープオブジェクトのリストに追加します。アリーナが破棄されると、このリストをトラバースして、各オブジェクトを `operator delete` を使用して解放します。このメソッドは、オブジェクトの寿命をアリーナに結び付ける必要があるが、何らかの理由でオブジェクト自体がアリーナ上に割り当てられていない場合などに便利です。
-   `template<typename T> void OwnDestructor(T* object)`: `object`のデストラクタをアリーナのデストラクタ呼び出しリストに追加します。アリーナが破棄されると、このリストをトラバースして、各デストラクタを順番に呼び出します。オブジェクトの基礎となるメモリを解放しようとはしません。このメソッドは、オブジェクトがアリーナに割り当てられたストレージに埋め込まれているが、そのデストラクタがそれ以外に呼び出されない場合に便利です。たとえば、その含まれるクラスがデストラクタが呼び出されないプロトコルバッファメッセージであるか、`AllocateArray()` によって割り当てられたブロック内で手動で構築されたためです。

### その他のメソッド {#other-methods}

-   `uint64 SpaceUsed() const`: アリーナの合計サイズを返します。これは基礎ブロックのサイズの合計です。このメソッドはスレッドセーフですが、複数のスレッドからの同時割り当てがある場合、このメソッドの戻り値にはそれらの新しいブロックのサイズが含まれないかもしれません。
-   `uint64 Reset()`: アリーナのストレージを破棄し、まずすべての登録されたデストラクタを呼び出し、すべての登録されたヒープオブジェクトを解放し、その後すべてのアリーナブロックを破棄します。このティアダウン手順は、アリーナのデストラクタが実行されるときに発生するものと同等ですが、このメソッドが返された後、アリーナは新しい割り当てのために再利用可能です。アリーナによって使用される合計サイズを返します。この情報はパフォーマンスの調整に役立ちます。
-   `template<typename T> Arena* GetArena()`: このアリーナへのポインタを返します。直接的にはあまり役立ちませんが、`GetArena()` メソッドが存在することを期待するテンプレートインスタンス化で `Arena` を使用することができます。

### スレッドセーフティ {#thread-safety}

`google::protobuf::Arena` の割り当てメソッドはスレッドセーフであり、
マルチスレッドの割り当てを高速化するために、基礎となる実装がいくつかの手法を講じています。`Reset()` メソッドは *スレッドセーフではありません*：アリーナのリセットを行うスレッドは、そのアリーナからの割り当てや割り当てされたオブジェクトを使用するすべてのスレッドと同期する必要があります。

## 生成されたメッセージクラス {#messageclass}

アリーナ割り当てを有効にすると、以下のメッセージクラスのメンバーが変更または追加されます。

### メッセージクラスのメソッド {#message-class-methods}

-   `Message(Message&& other)`: ソースメッセージがアリーナ上にない場合、ムーブコンストラクタは、この操作の時間複雑度が `O(宣言されたフィールドの数)` であるコピーまたはヒープ割り当てを行わずに、1 つのメッセージから別のメッセージにすべてのフィールドを *ムーブ* します。ただし、ソースメッセージがアリーナ上にある場合、基礎データの *ディープコピー* を実行します。いずれの場合も、ソースメッセージは有効ですが未指定の状態になります。
-   `Message& operator=(Message&& other)`: 両方のメッセージがアリーナ上にないか、*同じ* アリーナ上にある場合、ムーブ代入演算子は、この操作の時間複雑度が `O(宣言されたフィールドの数)` であるコピーまたはヒープ割り当てを行わずに、1 つのメッセージから別のメッセージにすべてのフィールドを *ムーブ* します。ただし、1 つのメッセージがアリーナ上にあるか、メッセージが異なるアリーナ上にある場合、基礎データの *ディープコピー* を実行します。いずれの場合も、ソースメッセージは有効ですが未指定の状態になります。
-   `void Swap(Message* other)`: 交換される両方のメッセージがアリーナ上にないか、*同じ* アリーナ上にある場合、[`Swap()`](/reference/cpp/cpp-generated#message) は、アリーナ割り当てが有効になっていない場合と同様に振る舞います：メッセージオブジェクトの内容を効率的に交換し、ほとんどが安価なポインタの交換を通じてコピーを回避します。ただし、1 つのメッセージがアリーナ上にある場合、またはメッセージが異なるアリーナ上にある場合、`Swap()` は基礎データの *ディープコピー* を実行します。この新しい振る舞いは、そうしないと、交換されたサブオブジェクトの寿命が異なる可能性があり、潜在的に使用後に解放されるバグが発生する可能性があるため、必要です。
-   `Message* New(Arena* arena)`: 標準の `New()` メソッドの代替オーバーライドです。このタイプの新しいメッセージオブジェクトを指定されたアリーナ上に作成することを可能にします。アリーナ上で生成された具象メッセージタイプで呼び出された場合、そのセマンティクスは `Arena::CreateMessage<T>(arena)` と同一です。メッセージタイプがアリーナ割り当てが有効になっていない場合、`arena` が NULL でない場合は通常の割り当てに続いて `arena->Own(message)` と同等です。
-   `Arena* GetArena()`: このメッセージオブジェクトが割り当てられたアリーナを返します。
-   `void UnsafeArenaSwap(Message* other)`: `Swap()` と同一ですが、両方のオブジェクトが同じアリーナ上にある（またはアリーナ上にない）と仮定し、この操作の効率的なポインタ交換実装を常に使用します。このメソッドを使用すると、`Swap()` とは異なり、スワップを実行する前にどのメッセージがどのアリーナ上に存在するかを確認する必要がないため、パフォーマンスが向上する可能性があります。`Unsafe` 接頭辞が示すように、スワップしたいメッセージが異なるアリーナ上にないことを確信している場合にのみ、このメソッドを使用する必要があります。そうでない場合、このメソッドは予測不可能な結果をもたらす可能性があります。

### 埋め込みメッセージフィールド {#arenaembeddedmessage}

メッセージオブジェクトをアリーナ上に割り当てると、その埋め込みメッセージフィールドオブジェクト（サブメッセージ）は自動的にアリーナによって所有されます。これらのメッセージオブジェクトがどのように割り当てられるかは、それらがどこで定義されているかによります:

-   もしメッセージタイプがアリーナ割り当てが有効になっている`.proto`ファイルでも定義されている場合、オブジェクトは直接アリーナ上に割り当てられます。
-   もしメッセージタイプがアリーナ割り当てが有効になっていない別の`.proto`から来ている場合、オブジェクトはヒープ上に割り当てられますが、親メッセージのアリーナによって「所有」されます。つまり、アリーナが破棄されると、オブジェクトはアリーナ自体のオブジェクトと一緒に解放されます。

これらのフィールド定義のいずれに対しても:

```proto
optional Bar foo = 1;
required Bar foo = 1;
```

以下のメソッドは、アリーナ割り当てが有効になっている場合に追加されるか特別な動作をします。それ以外の場合、アクセサメソッドは単に[デフォルトの動作](/reference/cpp/cpp-generated#embeddedmessage)を使用します。

-   `Bar* mutable_foo()`: サブメッセージインスタンスへのミュータブルなポインタを返します。親オブジェクトがアリーナ上にある場合、返されるオブジェクトも同様になります。
-   `void set_allocated_foo(Bar* bar)`: 新しいオブジェクトを取り、それをフィールドの新しい値として採用します。アリーナサポートは、オブジェクトがアリーナ/アリーナまたはアリーナ/ヒープの境界を越える際に適切な所有権を維持するための追加のコピーのセマンティクスを追加します:
    -   もし親オブジェクトがヒープ上にあり、`bar`もヒープ上にある場合、または親とメッセージが同じアリーナ上にある場合、このメソッドの動作は変わりません。
    -   もし親がアリーナ上にあり、`bar`がヒープ上にある場合、親メッセージは`bar`をそのアリーナの所有リストに`arena->Own()`で追加します。
    -   もし親がアリーナ上にあり、`bar`が別のアリーナ上にある場合、このメソッドはメッセージのコピーを作成し、そのコピーを新しいフィールド値として採用します。
-   `Bar* release_foo()`: フィールドの既存のサブメッセージインスタンスを返し、設定されている場合は所有権を呼び出し元に解放し、親メッセージのフィールドをクリアします。アリーナサポートは、返されるオブジェクトが常に*ヒープ上に割り当てられている*という契約を維持するための追加のコピーのセマンティクスを追加します:
    -   もし親メッセージがアリーナ上にある場合、このメソッドはサブメッセージをヒープ上にコピーし、フィールド値をクリアし、コピーを返します。
    -   もし親メッセージがヒープ上にある場合、メソッドの動作は変わりません。
-   `void unsafe_arena_set_allocated_foo(Bar* bar)`: `set_allocated_foo`と同じですが、親とサブメッセージが同じアリーナ上にあると仮定します。このバージョンのメソッドを使用すると、特定のアリーナまたはヒープ上にメッセージがあるかどうかをチェックする必要がないため、パフォーマンスが向上する可能性があります。詳細については、[割り当て/解放パターン](#set-allocated)を参照してください。
-   `Bar* unsafe_arena_release_foo()`: `release_foo()`に類似していますが、すべての所有権チェックをスキップします。詳細については、[割り当て/解放パターン](#set-allocated)を参照してください。

### 文字列フィールド {#arenastring}

文字列フィールドは、親メッセージがアリーナ上にある場合でも、データをヒープに格納します。そのため、文字列アクセサメソッドは、アリーナ割り当てが有効になっている場合でも、[デフォルトの動作](/reference/cpp/cpp-generated#string)を使用します。

### 繰り返しフィールド {#arenarepeated}

繰り返しフィールドは、含まれるメッセージがアリーナに割り当てられている場合、内部配列ストレージをアリーナに割り当て、また、これらの要素がポインタによって保持されている別々のオブジェクト（メッセージまたは文字列）もアリーナに割り当てます。メッセージクラスレベルでは、繰り返しフィールド用の生成されたメソッドは変更されません。ただし、アクセサによって返される`RepeatedField`および`RepeatedPtrField`オブジェクトは、アリーナサポートが有効になっている場合、新しいメソッドと変更されたセマンティクスを持ちます。

#### 繰り返し数値フィールド {#repeated-numeric}

プリミティブ型を含む`RepeatedField`オブジェクトは、アリーナ割り当てが有効になっている場合、以下の新しい/変更されたメソッドを持ちます。

-   `void UnsafeArenaSwap(RepeatedField* other)`: この繰り返しフィールドと他の繰り返しフィールドが同じアリーナ上にあるかどうかを検証せずに、`RepeatedField`の内容を交換します。異なるアリーナにある場合、2つの繰り返しフィールドオブジェクトは同等な寿命を持つアリーナ上にある必要があります。アリーナとヒープの場合はチェックされ、不許可となります。
-   `void Swap(RepeatedField* other)`: 各繰り返しフィールドオブジェクトのアリーナをチェックし、1つがアリーナ上にあり、もう1つがヒープ上にあるか、両方がアリーナ上にあるが異なる場合、スワップが行われる前に基礎配列がコピーされます。これにより、スワップ後、各繰り返しフィールドオブジェクトは、適切なアリーナまたはヒープ上に配列を保持します。

#### 繰り返し埋め込みメッセージフィールド {#repeated-embedded}

メッセージを含む`RepeatedPtrField`オブジェクトは、アリーナ割り当てが有効になっている場合、以下の新しい/変更されたメソッドを持ちます。

-   `void UnsafeArenaSwap(RepeatedPtrField* other)`: この繰り返しフィールドと他の繰り返しフィールドが同じアリーナポインタを持っているかどうかを検証せずに、`RepeatedPtrField`の内容を交換します。異なる場合、2つの繰り返しフィールドオブジェクトは同等な寿命を持つアリーナポインタを持つ必要があります。NULLでないアリーナポインタを持つものとNULLのアリーナポインタを持つものの場合はチェックされ、不許可となります。
-   `void Swap(RepeatedPtrField* other)`: 各繰り返しフィールドオブジェクトのアリーナポインタをチェックし、1つがNULLでない（アリーナ上の内容）で、もう1つがNULL（ヒープ上の内容）であるか、両方がNULLで異なる値を持つ場合、スワップが行われる前に基礎配列とそれに指されるオブジェクトがコピーされます。これにより、スワップ後、各繰り返しフィールドオブジェクトは、適切なアリーナまたはヒープ上に配列を保持します。
-   `void AddAllocated(SubMessageType* value)`: 提供されたメッセージオブジェクトが繰り返しフィールドのアリーナポインタと同じアリーナ上にあることを確認します。

    *   ソースと宛先の両方がアリーナに割り当てられ、同じアリーナにある場合：オブジェクトポインタは直接基礎となる配列に追加されます。
    *   ソースと宛先の両方がアリーナに割り当てられ、異なるアリーナにある場合：コピーが作成され、元のオブジェクトがヒープに割り当てられていた場合は解放され、コピーが配列に配置されます。
    *   ソースがヒープに割り当てられ、宛先がアリーナに割り当てられている場合：コピーは作成されません。
    *   ソースがアリーナに割り当てられ、宛先がヒープに割り当てられている場合：コピーが作成され、配列に配置されます。
    *   ソースと宛先の両方がヒープに割り当てられている場合：オブジェクトポインタは直接基礎となる配列に追加されます。

    これにより、繰り返しフィールドによって指されるすべてのオブジェクトが、繰り返しフィールドのアリーナポインタによって示される所有権ドメイン（ヒープまたは特定のアリーナ）と同じであるという不変条件が維持されます。

-   `SubMessageType* ReleaseLast()`: 繰り返しフィールド内の最後のメッセージに相当するヒープに割り当てられたメッセージを返し、それを繰り返しフィールドから削除します。繰り返しフィールド自体がNULLのアリーナポインタを持っている場合（したがって、指されるすべてのメッセージがヒープに割り当てられている場合）、このメソッドは単に元のオブジェクトへのポインタを返します。それ以外の場合、繰り返しフィールドがNULLでないアリーナポインタを持っている場合、このメソッドはヒープに割り当てられたコピーを作成し、そのコピーを返します。いずれの場合も、呼び出し元はヒープに割り当てられたオブジェクトの所有権を受け取り、オブジェクトの削除に責任を負います。

-   `void UnsafeArenaAddAllocated(SubMessageType* value)`: `AddAllocated()`と同様ですが、ヒープ/アリーナのチェックやメッセージのコピーは行いません。提供されたポインタをこの繰り返しフィールドの内部ポインタ配列に直接追加します。これの安全な使用方法については、[allocated/release patterns](#set-allocated)を参照してください。

-   `SubMessageType* UnsafeArenaReleaseLast()`: `ReleaseLast()`と同様ですが、繰り返しフィールドがNULLでないアリーナポインタを持っている場合でもコピーを行いません。代わりに、繰り返しフィールド内のオブジェクトへのポインタを直接返します。これの安全な使用方法については、[allocated/release patterns](#set-allocated)を参照してください。

-   `void ExtractSubrange(int start, int num, SubMessageType** elements)`:
    `start` インデックスから始まる繰り返しフィールドから `num` 個の要素を削除し、`elements` が NULL でない場合はそれらを返します。繰り返しフィールドがアリーナ上にある場合、かつ要素が返される場合、要素はまずヒープにコピーされます。アリーナの有無にかかわらず、呼び出し元がヒープ上の返されたオブジェクトを所有します。

-   `void UnsafeArenaExtractSubrange(int start, int num, SubMessageType** elements)`: `start` インデックスから始まる繰り返しフィールドから `num` 個の要素を削除し、`elements` が NULL でない場合はそれらを返します。`ExtractSubrange()` とは異なり、このメソッドは抽出された要素をコピーしません。詳細については、[allocated/release patterns](#set-allocated) を参照してください。

#### 繰り返し文字列フィールド {#repeated-string}

文字列の繰り返しフィールドは、メッセージの繰り返しフィールドと同様の新しいメソッドと変更されたセマンティクスを持っています。なぜなら、それらはポインタ参照によってその基礎オブジェクト（つまり、文字列）を維持しているからです。

## 使用パターンとベストプラクティス {#usage}

アリーナで割り当てられたメッセージを使用する際、いくつかの使用パターンは意図しないコピーまたは他のネガティブなパフォーマンス効果をもたらす可能性があります。アリーナ用にコードを適応する際に変更が必要な一般的なパターンについて認識しておくべきです（正しい動作が引き続き発生するよう API デザインに注意を払っていますが、より高性能なソリューションにはいくつかの再構築が必要かもしれません）。

### 意図しないコピー {#unintended}

アリーナ割り当てを使用しない場合にはオブジェクトのコピーを作成しないいくつかのメソッドが、アリーナサポートが有効になるとそれを行う可能性があります。これらの望ましくないコピーを避けるためには、オブジェクトが適切に割り当てられていることを確認し、または提供されるアリーナ固有のメソッドバージョンを使用することが重要です。詳細については以下を参照してください。

#### Set Allocated/Add Allocated/Release {#set-allocated}

デフォルトでは、単一メッセージフィールドの `release_field()` および `set_allocated_field()` メソッド、および繰り返しメッセージフィールドの `ReleaseLast()` および `AddAllocated()` メソッドは、ユーザーコードがサブメッセージを直接アタッチおよびデタッチし、データをコピーせずにポインタの所有権を渡すことを可能にします。

ただし、親メッセージがアリーナ上にある場合、これらのメソッドは今後、既存の所有権契約との互換性を維持するために、渡されたオブジェクトをコピーする必要がある場合があります。具体的には、所有権を持つメソッド（`set_allocated_field()` および `AddAllocated()`）は、親がアリーナ上にあり、新しいサブオブジェクトがそうでない場合、またはその逆である場合、または異なるアリーナにある場合、データをコピーするかもしれません。所有権を解放するメソッド（`release_field()` および `ReleaseLast()`）は、親がアリーナ上にある場合、データをコピーするかもしれません。なぜなら、契約上、返されるオブジェクトはヒープ上になければならないからです。

このようなコピーを避けるために、これらのメソッドの対応する「unsafe arena」バージョンを追加しました。ここでは、コピーが**決して行われない**メソッドが含まれます：`unsafe_arena_set_allocated_field()`、`unsafe_arena_release_field()`、`UnsafeArenaAddAllocated()`、および `UnsafeArenaRelease()` は、それぞれ単数および繰り返しフィールド用です。これらのメソッドは、安全であるとわかっている場合にのみ使用する必要があります。これらのメソッドには、次の2つの一般的なパターンがあります：

- 同じアリーナの部分間でメッセージツリーを移動すること。この場合に安全であるためには、メッセージが同じアリーナにある必要があります。
- 所有されているメッセージを一時的にツリーに貸し出してコピーを回避すること。安全な *add*/*set* メソッドと対応する安全でない *release* メソッドをペアにすることで、どちらのメッセージが所有されているかに関係なく、最も安価な方法で貸し出しを行います（このパターンは、それらが同じアリーナにある場合、異なるアリーナにある場合、またはアリーナが全くない場合に機能します）。安全な *add*/*set* とそれに対応する *release* の間では、借り手はスワップ、移動、クリア、または破壊されてはならず、貸し出されたメッセージはスワップまたは移動されてはならず、貸し出されたメッセージは借り手によってクリアまたは解放されてはならず、貸し出されたメッセージは破壊されてはなりません。

これらのメソッドを使用して不要なコピーを回避する方法の例を以下に示します。アリーナ上に以下のメッセージを作成したとします。

```cpp
Arena* arena = new google::protobuf::Arena();
MyFeatureMessage* arena_message_1 =
  google::protobuf::Arena::CreateMessage<MyFeatureMessage>(arena);
arena_message_1->mutable_nested_message()->set_feature_id(11);

MyFeatureMessage* arena_message_2 =
  google::protobuf::Arena::CreateMessage<MyFeatureMessage>(arena);
```

次のコードは、`release_...()` APIの効率的でない使用例です：

```cpp
arena_message_2->set_allocated_nested_message(arena_message_1->release_nested_message());

arena_message_1->release_message(); // ネストされたメッセージの基になるポインタのコピーを返し、基になるポインタを削除します
```

```cpp
arena_message_2->unsafe_arena_set_allocated_nested_message(
   arena_message_1->unsafe_arena_release_nested_message());
```

これらのメソッドについては、[埋め込みメッセージフィールド](#arenaembeddedmessage)セクションで詳細を確認できます。

#### スワップ {#swap}

2つのメッセージの内容を`Swap()`で入れ替えると、2つのメッセージが異なるアリーナに存在する場合や、1つがアリーナにありもう1つがヒープにある場合に、基礎となるサブオブジェクトがコピーされる可能性があります。このコピーを避けたい場合は、(i) 2つのメッセージが同じアリーナにあるか、異なるアリーナにあるがアリーナの寿命が同等であることを知っているか、または(ii) 2つのメッセージがヒープにあることを知っている場合、`UnsafeArenaSwap()`という新しいメソッドを使用できます。このメソッドは、アリーナのチェックを実行するオーバーヘッドを回避し、コピーが発生する場合にもそれを回避します。

例えば、次のコードは`Swap()`呼び出しでコピーが発生します:

```cpp
MyFeatureMessage* message_1 =
  google::protobuf::Arena::CreateMessage<MyFeatureMessage>(arena);
message_1->mutable_nested_message()->set_feature_id(11);

MyFeatureMessage* message_2 = new MyFeatureMessage;
message_2->mutable_nested_message()->set_feature_id(22);

message_1->Swap(message_2); // Inefficient swap!
```

このコードでコピーを回避するには、`message_2`を`message_1`と同じアリーナに割り当てます:

```cpp
MyFeatureMessage* message_2 =
   google::protobuf::Arena::CreateMessage<MyFeatureMessage>(arena);
```

### 粒度 {#granularity}

ほとんどのアプリケーションサーバーのユースケースでは、"リクエストごとのアリーナ"モデルがうまく機能することがわかっています。アリーナの使用をさらに分割することが誘惑されるかもしれませんが、それはヒープのオーバーヘッドを減らすため（より小さなアリーナをより頻繁に破棄することによって）または知覚されるスレッド競合の問題を減らすためかもしれません。ただし、より細かい粒度のアリーナの使用は、上記で説明したように意図しないメッセージのコピーにつながる可能性があります。また、`Arena`の実装をマルチスレッドのユースケースに最適化するために努力してきたため、複数のスレッドがそのリクエストを処理しても、リクエストの寿命全体で単一のアリーナを使用するのが適切です。

## 例 {#example}

以下は、アリーナ割り当てAPIのいくつかの機能を示すシンプルな完全な例です。

```proto
// my_feature.proto

syntax = "proto2";
import "nested_message.proto";

package feature_package;

// NEXT Tag to use: 4
message MyFeatureMessage {
  optional string feature_name = 1;
  repeated int32 feature_data = 2;
  optional NestedMessage nested_message = 3;
};
```

```proto
// nested_message.proto

syntax = "proto2";

package feature_package;

// NEXT Tag to use: 2
message NestedMessage {
  optional int32 feature_id = 1;
};
```

メッセージの構築と解放:

```cpp
#include <google/protobuf/arena.h>

Arena arena;

MyFeatureMessage* arena_message =
   google::protobuf::Arena::CreateMessage<MyFeatureMessage>(&arena);

arena_message->set_feature_name("Proto2 Arena");
arena_message->mutable_feature_data()->Add(2);
arena_message->mutable_feature_data()->Add(4);
arena_message->mutable_nested_message()->set_feature_id(247);
```
