+++
title = "gzip_stream.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/io/gzip_stream.h&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>This file contains the definition for classes <a href='#GzipInputStream'>GzipInputStream</a> and <a href='#GzipOutputStream'>GzipOutputStream</a>. </p><p><a href='#GzipInputStream'>GzipInputStream</a> decompresses data from an underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> and provides the decompressed data as a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a>.</p>

<p><a href='#GzipOutputStream'>GzipOutputStream</a> is an <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> that compresses data to an underlying <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a>. </p>

<table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#GzipInputStream">GzipInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> that reads compressed data through zlib. </div></td></tr><tr><td><div><code><a href="#GzipOutputStream">GzipOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"></div></td></tr><tr><td><div><code><a href="#GzipOutputStream.Options">GzipOutputStream::Options</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"></div></td></tr></table><h2 id="GzipInputStream">class GzipInputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyInputStream">ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/gzip_stream.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> that reads compressed data through zlib. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>enum</code></td><td style="border-left-width: 0px"id="GzipInputStream.Format"><div style="padding-left: 16px; text-indent: -16px"><code><b>Format</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Format key for constructor.  <a href="#GzipInputStream.Format.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="GzipInputStream.GzipInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>GzipInputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> * sub_stream, <a href='#GzipInputStream.Format'>Format</a> format = <a href='#GzipInputStream.Format'>AUTO</a>, int buffer_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">buffer_size and format may be -1 for default of 64kB and GZIP format </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="GzipInputStream.~GzipInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~GzipInputStream</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const char *</code></td><td style="border-left-width: 0px"id="GzipInputStream.ZlibErrorMessage"><div style="padding-left: 16px; text-indent: -16px"><code><b>ZlibErrorMessage</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Return last error message or NULL if no error. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="GzipInputStream.ZlibErrorCode"><div style="padding-left: 16px; text-indent: -16px"><code><b>ZlibErrorCode</b>() const</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="GzipInputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a chunk of data from the stream.  <a href="#GzipInputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="GzipInputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the next call to <a href='#GzipInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#GzipInputStream.Next'>Next()</a>.  <a href="#GzipInputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="GzipInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#GzipInputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64</code></td><td style="border-left-width: 0px"id="GzipInputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes read since this object was created. </div></td></tr></table> <hr><h3 id="GzipInputStream.Format.details"><code>enum GzipInputStream::Format {<br>&nbsp;&nbsp;AUTO = = 0,<br>&nbsp;&nbsp;GZIP = = 1,<br>&nbsp;&nbsp;ZLIB = = 2<br>}</code></h3><div style="margin-left: 16px"><p>Format key for constructor. </p><table><tr><td>AUTO</td><td>zlib will autodetect gzip header or deflate stream </td></tr><tr><td>GZIP</td><td>GZIP streams have some extra header data for file attributes. </td></tr><tr><td>ZLIB</td><td>Simpler zlib stream format. </td></tr></table></div> <hr><h3 id="GzipInputStream.Next.details"><code>virtual bool GzipInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a chunk of data from the stream. </p><p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#GzipInputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="GzipInputStream.BackUp.details"><code>virtual void GzipInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the next call to <a href='#GzipInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#GzipInputStream.Next'>Next()</a>. </p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href='#GzipInputStream.Next'>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href='#GzipInputStream.BackUp'>BackUp()</a> to return to the point where you intended to finish.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#GzipInputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#GzipInputStream.Next'>Next()</a>.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#GzipInputStream.Next'>Next()</a> will be pushed back into the stream. Subsequent calls to <a href='#GzipInputStream.Next'>Next()</a> will return the same data again before producing new data. </li>
</ul>
</div> <hr><h3 id="GzipInputStream.Skip.details"><code>virtual bool GzipInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href='#GzipInputStream.ByteCount'>ByteCount()</a> will return the total size of the stream). </p>
</div><h2 id="GzipOutputStream">class GzipOutputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream">ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/gzip_stream.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p></p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>enum</code></td><td style="border-left-width: 0px"id="GzipOutputStream.Format"><div style="padding-left: 16px; text-indent: -16px"><code><b>Format</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Format key for constructor.  <a href="#GzipOutputStream.Format.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="GzipOutputStream.GzipOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>GzipOutputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * sub_stream)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create a <a href='#GzipOutputStream'>GzipOutputStream</a> with default options. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="GzipOutputStream.GzipOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>GzipOutputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> * sub_stream, const <a href='#GzipOutputStream.Options'>Options</a> &amp; options)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create a <a href='#GzipOutputStream'>GzipOutputStream</a> with the given options. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="GzipOutputStream.~GzipOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~GzipOutputStream</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const char *</code></td><td style="border-left-width: 0px"id="GzipOutputStream.ZlibErrorMessage"><div style="padding-left: 16px; text-indent: -16px"><code><b>ZlibErrorMessage</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Return last error message or NULL if no error. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="GzipOutputStream.ZlibErrorCode"><div style="padding-left: 16px; text-indent: -16px"><code><b>ZlibErrorCode</b>() const</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="GzipOutputStream.Flush"><div style="padding-left: 16px; text-indent: -16px"><code><b>Flush</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Flushes data written so far to zipped data in the underlying stream.  <a href="#GzipOutputStream.Flush.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="GzipOutputStream.Close"><div style="padding-left: 16px; text-indent: -16px"><code><b>Close</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Writes out all data and closes the gzip stream.  <a href="#GzipOutputStream.Close.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="GzipOutputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a buffer into which data can be written.  <a href="#GzipOutputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="GzipOutputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the end of the last buffer returned by <a href='#GzipOutputStream.Next'>Next()</a> is not actually written.  <a href="#GzipOutputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64</code></td><td style="border-left-width: 0px"id="GzipOutputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes written since this object was created. </div></td></tr></table> <hr><h3 id="GzipOutputStream.Format.details"><code>enum GzipOutputStream::Format {<br>&nbsp;&nbsp;GZIP = = 1,<br>&nbsp;&nbsp;ZLIB = = 2<br>}</code></h3><div style="margin-left: 16px"><p>Format key for constructor. </p><table><tr><td>GZIP</td><td>GZIP streams have some extra header data for file attributes. </td></tr><tr><td>ZLIB</td><td>Simpler zlib stream format. </td></tr></table></div> <hr><h3 id="GzipOutputStream.Flush.details"><code>bool GzipOutputStream::Flush()</code></h3><div style="margin-left: 16px"><p>Flushes data written so far to zipped data in the underlying stream. </p><p>It is the caller's responsibility to flush the underlying stream if necessary. Compression may be less efficient stopping and starting around flushes. Returns true if no error.</p>
<p>Please ensure that block size is &gt; 6. Here is an excerpt from the zlib doc that explains why:</p>
<p>In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that avail_out is greater than six to avoid repeated flush markers due to avail_out == 0 on return. </p>
</div> <hr><h3 id="GzipOutputStream.Close.details"><code>bool GzipOutputStream::Close()</code></h3><div style="margin-left: 16px"><p>Writes out all data and closes the gzip stream. </p><p>It is the caller's responsibility to close the underlying stream if necessary. Returns true if no error. </p>
</div> <hr><h3 id="GzipOutputStream.Next.details"><code>virtual bool GzipOutputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a buffer into which data can be written. </p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p>
<p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href='#GzipOutputStream.BackUp'>BackUp()</a> is called).</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#GzipOutputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="GzipOutputStream.BackUp.details"><code>virtual void GzipOutputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href='#GzipOutputStream.Next'>Next()</a> is not actually written. </p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href='#GzipOutputStream.BackUp'>BackUp()</a> to back up.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#GzipOutputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#GzipOutputStream.Next'>Next()</a>.</li>
  <li>The caller must not have written anything to the last "count" bytes of that buffer.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#GzipOutputStream.Next'>Next()</a> will be ignored. </li>
</ul>
</div><h2 id="GzipOutputStream.Options">struct GzipOutputStream::Options</h2><p><code>#include &lt;<a href="#">google/protobuf/io/gzip_stream.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p></p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#GzipOutputStream.Format'>Format</a></code></td><td style="border-left-width: 0px"id="GzipOutputStream.Options.format"><div style="padding-left: 16px; text-indent: -16px"><code><b>format</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Defaults to GZIP. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="GzipOutputStream.Options.buffer_size"><div style="padding-left: 16px; text-indent: -16px"><code><b>buffer_size</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">What size buffer to use internally. Defaults to 64kB. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="GzipOutputStream.Options.compression_level"><div style="padding-left: 16px; text-indent: -16px"><code><b>compression_level</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A number between 0 and 9, where 0 is no compression and 9 is best compression.  <a href="#GzipOutputStream.Options.compression_level.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="GzipOutputStream.Options.compression_strategy"><div style="padding-left: 16px; text-indent: -16px"><code><b>compression_strategy</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Defaults to Z_DEFAULT_STRATEGY.  <a href="#GzipOutputStream.Options.compression_strategy.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="GzipOutputStream.Options.Options"><div style="padding-left: 16px; text-indent: -16px"><code><b>Options</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Initializes with default values. </div></td></tr></table> <hr><h3 id="GzipOutputStream.Options.compression_level.details"><code>intOptions::compression_level</code></h3><div style="margin-left: 16px"><p>A number between 0 and 9, where 0 is no compression and 9 is best compression. </p><p>Defaults to Z_DEFAULT_COMPRESSION (see zlib.h). </p>
</div> <hr><h3 id="GzipOutputStream.Options.compression_strategy.details"><code>intOptions::compression_strategy</code></h3><div style="margin-left: 16px"><p>Defaults to Z_DEFAULT_STRATEGY. </p><p>Can also be set to Z_FILTERED, Z_HUFFMAN_ONLY, or Z_RLE. See the documentation for deflateInit2 in zlib.h for definitions of these constants. </p>
</div>
