+++
title = "tokenizer.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/io/tokenizer.h&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>Class for parsing tokenized text from a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a>. </p><table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#ErrorCollector">ErrorCollector</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Abstract interface for an object which collects the errors that occur during parsing. </div></td></tr><tr><td><div><code><a href="#Tokenizer">Tokenizer</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">This class converts a stream of raw text into a stream of tokens for the protocol definition parser to parse. </div></td></tr><tr><td><div><code><a href="#Tokenizer.Token">Tokenizer::Token</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Structure representing a token read from the token stream. </div></td></tr></table><table><tr><th colspan="2"><h3 style="margin-top: 4px">File Members</h3><div style="font-style: italic; font-weight: normal;">These definitions are not part of any class.</div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>typedef</code></td><td style="border-left-width: 0px"id="ColumnNumber"><div style="padding-left: 16px; text-indent: -16px"><code>int <b>ColumnNumber</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">By "column number", the proto compiler refers to a count of the number of bytes before a given byte, except that a tab character advances to the next multiple of 8 bytes.  <a href="#ColumnNumber.details">more...</a></div></td></tr></table> <hr><h3 id="ColumnNumber.details"><code>typedef io::ColumnNumber</code></h3><div style="margin-left: 16px"><p>By "column number", the proto compiler refers to a count of the number of bytes before a given byte, except that a tab character advances to the next multiple of 8 bytes. </p><p>Note in particular that column numbers are zero-based, while many user interfaces use one-based column numbers. </p>
</div><h2 id="ErrorCollector">class ErrorCollector</h2><p><code>#include &lt;<a href="#">google/protobuf/io/tokenizer.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>Abstract interface for an object which collects the errors that occur during parsing. </p><p>A typical implementation might simply print the errors to stdout. </p>

<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="ErrorCollector.ErrorCollector"><div style="padding-left: 16px; text-indent: -16px"><code><b>ErrorCollector</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="ErrorCollector.~ErrorCollector"><div style="padding-left: 16px; text-indent: -16px"><code><b>~ErrorCollector</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="ErrorCollector.AddError"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddError</b>(int line, <a href='#ColumnNumber'>ColumnNumber</a> column, const std::string &amp; message)  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Indicates that there was an error in the input at the given line and column numbers.  <a href="#ErrorCollector.AddError.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="ErrorCollector.AddWarning"><div style="padding-left: 16px; text-indent: -16px"><code><b>AddWarning</b>(int , <a href='#ColumnNumber'>ColumnNumber</a> , const std::string &amp; )</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Indicates that there was a warning in the input at the given line and column numbers.  <a href="#ErrorCollector.AddWarning.details">more...</a></div></td></tr></table> <hr><h3 id="ErrorCollector.AddError.details"><code>virtual void ErrorCollector::AddError(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int line,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ColumnNumber'>ColumnNumber</a> column,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; message)  = 0</code></h3><div style="margin-left: 16px"><p>Indicates that there was an error in the input at the given line and column numbers. </p><p>The numbers are zero-based, so you may want to add 1 to each before printing them. </p>
</div> <hr><h3 id="ErrorCollector.AddWarning.details"><code>virtual void ErrorCollector::AddWarning(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int ,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ColumnNumber'>ColumnNumber</a> ,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; )</code></h3><div style="margin-left: 16px"><p>Indicates that there was a warning in the input at the given line and column numbers. </p><p>The numbers are zero-based, so you may want to add 1 to each before printing them. </p>
</div><h2 id="Tokenizer">class Tokenizer</h2><p><code>#include &lt;<a href="#">google/protobuf/io/tokenizer.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>This class converts a stream of raw text into a stream of tokens for the protocol definition parser to parse. </p><p>The tokens recognized are similar to those that make up the C language; see the TokenType enum for precise descriptions. Whitespace and comments are skipped. By default, C- and C++-style comments are recognized, but other styles can be used by calling <a href='#Tokenizer.set_comment_style'>set_comment_style()</a>. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>enum</code></td><td style="border-left-width: 0px"id="Tokenizer.TokenType"><div style="padding-left: 16px; text-indent: -16px"><code><b>TokenType</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;"> <a href="#Tokenizer.TokenType.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="Tokenizer.Tokenizer"><div style="padding-left: 16px; text-indent: -16px"><code><b>Tokenizer</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> * input, <a href='#ErrorCollector'>ErrorCollector</a> * error_collector)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Construct a <a href='#Tokenizer'>Tokenizer</a> that reads and tokenizes text from the given input stream and writes errors to the given error_collector.  <a href="#Tokenizer.Tokenizer.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="Tokenizer.~Tokenizer"><div style="padding-left: 16px; text-indent: -16px"><code><b>~Tokenizer</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const <a href='#Tokenizer.Token'>Token</a> &amp;</code></td><td style="border-left-width: 0px"id="Tokenizer.current"><div style="padding-left: 16px; text-indent: -16px"><code><b>current</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Get the current token.  <a href="#Tokenizer.current.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>const <a href='#Tokenizer.Token'>Token</a> &amp;</code></td><td style="border-left-width: 0px"id="Tokenizer.previous"><div style="padding-left: 16px; text-indent: -16px"><code><b>previous</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Return the previous token &ndash; i.e.  <a href="#Tokenizer.previous.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="Tokenizer.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Advance to the next token.  <a href="#Tokenizer.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="Tokenizer.NextWithComments"><div style="padding-left: 16px; text-indent: -16px"><code><b>NextWithComments</b>(std::string * prev_trailing_comments, std::vector&lt; std::string &gt; * detached_comments, std::string * next_leading_comments)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Like <a href='#Tokenizer.Next'>Next()</a>, but also collects comments which appear between the previous and next tokens.  <a href="#Tokenizer.NextWithComments.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Options</h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>enum</code></td><td style="border-left-width: 0px"id="Tokenizer.CommentStyle"><div style="padding-left: 16px; text-indent: -16px"><code><b>CommentStyle</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Valid values for <a href='#Tokenizer.set_comment_style'>set_comment_style()</a>.  <a href="#Tokenizer.CommentStyle.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Tokenizer.set_allow_f_after_float"><div style="padding-left: 16px; text-indent: -16px"><code><b>set_allow_f_after_float</b>(bool value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Set true to allow floats to be suffixed with the letter 'f'.  <a href="#Tokenizer.set_allow_f_after_float.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Tokenizer.set_comment_style"><div style="padding-left: 16px; text-indent: -16px"><code><b>set_comment_style</b>(<a href='#Tokenizer.CommentStyle'>CommentStyle</a> style)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Sets the comment style. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Tokenizer.set_require_space_after_number"><div style="padding-left: 16px; text-indent: -16px"><code><b>set_require_space_after_number</b>(bool require)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Whether to require whitespace between a number and a field name.  <a href="#Tokenizer.set_require_space_after_number.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="Tokenizer.set_allow_multiline_strings"><div style="padding-left: 16px; text-indent: -16px"><code><b>set_allow_multiline_strings</b>(bool allow)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Whether to allow string literals to span multiple lines.  <a href="#Tokenizer.set_allow_multiline_strings.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static bool</code></td><td style="border-left-width: 0px"id="Tokenizer.IsIdentifier"><div style="padding-left: 16px; text-indent: -16px"><code><b>IsIdentifier</b>(const std::string &amp; text)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">External helper: validate an identifier. </div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">Parse helpers</h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static double</code></td><td style="border-left-width: 0px"id="Tokenizer.ParseFloat"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseFloat</b>(const std::string &amp; text)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Parses a TYPE_FLOAT token.  <a href="#Tokenizer.ParseFloat.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static void</code></td><td style="border-left-width: 0px"id="Tokenizer.ParseString"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseString</b>(const std::string &amp; text, std::string * output)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Parses a TYPE_STRING token.  <a href="#Tokenizer.ParseString.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static void</code></td><td style="border-left-width: 0px"id="Tokenizer.ParseStringAppend"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseStringAppend</b>(const std::string &amp; text, std::string * output)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Identical to ParseString, but appends to output. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>static bool</code></td><td style="border-left-width: 0px"id="Tokenizer.ParseInteger"><div style="padding-left: 16px; text-indent: -16px"><code><b>ParseInteger</b>(const std::string &amp; text, uint64 max_value, uint64 * output)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Parses a TYPE_INTEGER token.  <a href="#Tokenizer.ParseInteger.details">more...</a></div></td></tr></table> <hr><h3 id="Tokenizer.TokenType.details"><code>enum Tokenizer::TokenType {<br>&nbsp;&nbsp;TYPE_START,<br>&nbsp;&nbsp;TYPE_END,<br>&nbsp;&nbsp;TYPE_IDENTIFIER,<br>&nbsp;&nbsp;TYPE_INTEGER,<br>&nbsp;&nbsp;TYPE_FLOAT,<br>&nbsp;&nbsp;TYPE_STRING,<br>&nbsp;&nbsp;TYPE_SYMBOL<br>}</code></h3><div style="margin-left: 16px"><p></p><table><tr><td>TYPE_START</td><td><a href='#Tokenizer.Next'>Next()</a> has not yet been called. </td></tr><tr><td>TYPE_END</td><td>End of input reached. "text" is empty. </td></tr><tr><td>TYPE_IDENTIFIER</td><td><p>A sequence of letters, digits, and underscores, not starting with a digit. </p><p>It is an error for a number to be followed by an identifier with no space in between. </p>
</td></tr><tr><td>TYPE_INTEGER</td><td><p>A sequence of digits representing an integer. </p><p>Normally the digits are decimal, but a prefix of "0x" indicates a hex number and a leading zero indicates octal, just like with C numeric literals. A leading negative sign is NOT included in the token; it's up to the parser to interpret the unary minus operator on its own. </p>
</td></tr><tr><td>TYPE_FLOAT</td><td><p>A floating point literal, with a fractional part and/or an exponent. </p><p>Always in decimal. Again, never negative. </p>
</td></tr><tr><td>TYPE_STRING</td><td><p>A quoted sequence of escaped characters. </p><p>Either single or double quotes can be used, but they must match. A string literal cannot cross a line break. </p>
</td></tr><tr><td>TYPE_SYMBOL</td><td><p>Any other printable character, like '!' or '+'. </p><p>Symbols are always a single character, so "!+$%" is four tokens. </p>
</td></tr></table></div> <hr><h3 id="Tokenizer.Tokenizer.details"><code> Tokenizer::Tokenizer(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> * input,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#ErrorCollector'>ErrorCollector</a> * error_collector)</code></h3><div style="margin-left: 16px"><p>Construct a <a href='#Tokenizer'>Tokenizer</a> that reads and tokenizes text from the given input stream and writes errors to the given error_collector. </p><p>The caller keeps ownership of input and error_collector. </p>
</div> <hr><h3 id="Tokenizer.current.details"><code>const <a href='#Tokenizer.Token'>Token</a> &amp; Tokenizer::current()</code></h3><div style="margin-left: 16px"><p>Get the current token. </p><p>This is updated when <a href='#Tokenizer.Next'>Next()</a> is called. Before the first call to <a href='#Tokenizer.Next'>Next()</a>, <a href='#Tokenizer.current'>current()</a> has type TYPE_START and no contents. </p>
</div> <hr><h3 id="Tokenizer.previous.details"><code>const <a href='#Tokenizer.Token'>Token</a> &amp; Tokenizer::previous()</code></h3><div style="margin-left: 16px"><p>Return the previous token &ndash; i.e. </p><p>what <a href='#Tokenizer.current'>current()</a> returned before the previous call to <a href='#Tokenizer.Next'>Next()</a>. </p>
</div> <hr><h3 id="Tokenizer.Next.details"><code>bool Tokenizer::Next()</code></h3><div style="margin-left: 16px"><p>Advance to the next token. </p><p>Returns false if the end of the input is reached. </p>
</div> <hr><h3 id="Tokenizer.NextWithComments.details"><code>bool Tokenizer::NextWithComments(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * prev_trailing_comments,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt; std::string &gt; * detached_comments,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * next_leading_comments)</code></h3><div style="margin-left: 16px"><p>Like <a href='#Tokenizer.Next'>Next()</a>, but also collects comments which appear between the previous and next tokens. </p><p>Comments which appear to be attached to the previous token are stored in *prev_tailing_comments. Comments which appear to be attached to the next token are stored in *next_leading_comments. Comments appearing in between which do not appear to be attached to either will be added to detached_comments. Any of these parameters can be NULL to simply discard the comments.</p>
<p>A series of line comments appearing on consecutive lines, with no other tokens appearing on those lines, will be treated as a single comment.</p>
<p>Only the comment content is returned; comment markers (e.g. //) are stripped out. For block comments, leading whitespace and an asterisk will be stripped from the beginning of each line other than the first. Newlines are included in the output.</p>
<p>Examples:</p>
<pre>optional int32 foo = 1;  // Comment attached to foo.
// Comment attached to bar.
optional int32 bar = 2;

optional string baz = 3;
// Comment attached to baz.
// Another line attached to baz.

// Comment attached to qux.
//
// Another line attached to qux.
optional double qux = 4;

// Detached comment.  This is not attached to qux or corge
// because there are blank lines separating it from both.

optional string corge = 5;
/* Block comment attached
 * to corge.  Leading asterisks
 * will be removed. * /
/* Block comment attached to
 * grault. * /
optional int32 grault = 6;
   *  </pre>
</div> <hr><h3 id="Tokenizer.CommentStyle.details"><code>enum Tokenizer::CommentStyle {<br>&nbsp;&nbsp;CPP_COMMENT_STYLE,<br>&nbsp;&nbsp;SH_COMMENT_STYLE<br>}</code></h3><div style="margin-left: 16px"><p>Valid values for <a href='#Tokenizer.set_comment_style'>set_comment_style()</a>. </p><table><tr><td>CPP_COMMENT_STYLE</td><td>Line comments begin with "//", block comments are delimited by "/*" and "* /". </td></tr><tr><td>SH_COMMENT_STYLE</td><td>Line comments begin with "#". No way to write block comments. </td></tr></table></div> <hr><h3 id="Tokenizer.set_allow_f_after_float.details"><code>void Tokenizer::set_allow_f_after_float(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool value)</code></h3><div style="margin-left: 16px"><p>Set true to allow floats to be suffixed with the letter 'f'. </p><p>Tokens which would otherwise be integers but which have the 'f' suffix will be forced to be interpreted as floats. For all other purposes, the 'f' is ignored. </p>
</div> <hr><h3 id="Tokenizer.set_require_space_after_number.details"><code>void Tokenizer::set_require_space_after_number(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool require)</code></h3><div style="margin-left: 16px"><p>Whether to require whitespace between a number and a field name. </p><p>Default is true. Do not use this; for Google-internal cleanup only. </p>
</div> <hr><h3 id="Tokenizer.set_allow_multiline_strings.details"><code>void Tokenizer::set_allow_multiline_strings(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool allow)</code></h3><div style="margin-left: 16px"><p>Whether to allow string literals to span multiple lines. </p><p>Default is false. Do not use this; for Google-internal cleanup only. </p>
</div> <hr><h3 id="Tokenizer.ParseFloat.details"><code>static double Tokenizer::ParseFloat(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; text)</code></h3><div style="margin-left: 16px"><p>Parses a TYPE_FLOAT token. </p><p>This never fails, so long as the text actually comes from a TYPE_FLOAT token parsed by <a href='#Tokenizer'>Tokenizer</a>. If it doesn't, the result is undefined (possibly an assert failure). </p>
</div> <hr><h3 id="Tokenizer.ParseString.details"><code>static void Tokenizer::ParseString(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; text,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * output)</code></h3><div style="margin-left: 16px"><p>Parses a TYPE_STRING token. </p><p>This never fails, so long as the text actually comes from a TYPE_STRING token parsed by <a href='#Tokenizer'>Tokenizer</a>. If it doesn't, the result is undefined (possibly an assert failure). </p>
</div> <hr><h3 id="Tokenizer.ParseInteger.details"><code>static bool Tokenizer::ParseInteger(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string &amp; text,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64 max_value,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64 * output)</code></h3><div style="margin-left: 16px"><p>Parses a TYPE_INTEGER token. </p><p>Returns false if the result would be greater than max_value. Otherwise, returns true and sets *output to the result. If the text is not from a <a href='#Tokenizer.Token'>Token</a> of type TYPE_INTEGER originally parsed by a <a href='#Tokenizer'>Tokenizer</a>, the result is undefined (possibly an assert failure). </p>
</div><h2 id="Tokenizer.Token">struct Tokenizer::Token</h2><p><code>#include &lt;<a href="#">google/protobuf/io/tokenizer.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>Structure representing a token read from the token stream. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#Tokenizer.TokenType'>TokenType</a></code></td><td style="border-left-width: 0px"id="Tokenizer.Token.type"><div style="padding-left: 16px; text-indent: -16px"><code><b>type</b></code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::string</code></td><td style="border-left-width: 0px"id="Tokenizer.Token.text"><div style="padding-left: 16px; text-indent: -16px"><code><b>text</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">The exact text of the token as it appeared in the input.  <a href="#Tokenizer.Token.text.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="Tokenizer.Token.line"><div style="padding-left: 16px; text-indent: -16px"><code><b>line</b></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">"line" and "column" specify the position of the first character of the token within the input stream.  <a href="#Tokenizer.Token.line.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#ColumnNumber'>ColumnNumber</a></code></td><td style="border-left-width: 0px"id="Tokenizer.Token.column"><div style="padding-left: 16px; text-indent: -16px"><code><b>column</b></code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code><a href='#ColumnNumber'>ColumnNumber</a></code></td><td style="border-left-width: 0px"id="Tokenizer.Token.end_column"><div style="padding-left: 16px; text-indent: -16px"><code><b>end_column</b></code></div></td></tr></table> <hr><h3 id="Tokenizer.Token.text.details"><code>std::string Token::text</code></h3><div style="margin-left: 16px"><p>The exact text of the token as it appeared in the input. </p><p>e.g. tokens of TYPE_STRING will still be escaped and in quotes. </p>
</div> <hr><h3 id="Tokenizer.Token.line.details"><code>int Token::line</code></h3><div style="margin-left: 16px"><p>"line" and "column" specify the position of the first character of the token within the input stream. </p><p>They are zero-based. </p>
</div>
