+++
title = "zero_copy_stream_iml_lite.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/io/zero_copy_stream_impl_lite.h&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>This file contains common implementations of the interfaces defined in <a href='google.protobuf.io.zero_copy_stream'>zero_copy_stream.h</a> which are included in the "lite" protobuf library. </p><p>These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases. </p>

<table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#ArrayInputStream">ArrayInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> backed by an in-memory array of bytes. </div></td></tr><tr><td><div><code><a href="#ArrayOutputStream">ArrayOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> backed by an in-memory array of bytes. </div></td></tr><tr><td><div><code><a href="#StringOutputStream">StringOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which appends bytes to a string. </div></td></tr><tr><td><div><code><a href="#CopyingInputStream">CopyingInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A generic traditional input stream interface. </div></td></tr><tr><td><div><code><a href="#CopyingInputStreamAdaptor">CopyingInputStreamAdaptor</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from a <a href='#CopyingInputStream'>CopyingInputStream</a>. </div></td></tr><tr><td><div><code><a href="#CopyingOutputStream">CopyingOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A generic traditional output stream interface. </div></td></tr><tr><td><div><code><a href="#CopyingOutputStreamAdaptor">CopyingOutputStreamAdaptor</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which writes to a <a href='#CopyingOutputStream'>CopyingOutputStream</a>. </div></td></tr><tr><td><div><code><a href="#LimitingInputStream">LimitingInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which wraps some other stream and limits it to a particular byte count. </div></td></tr></table><table><tr><th colspan="2"><h3 style="margin-top: 4px">File Members</h3><div style="font-style: italic; font-weight: normal;">These definitions are not part of any class.</div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>char *</code></td><td style="border-left-width: 0px"id="mutable_string_data"><div style="padding-left: 16px; text-indent: -16px"><code><b>mutable_string_data</b>(std::string * s)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Return a pointer to mutable characters underlying the given string.  <a href="#mutable_string_data.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>std::pair&lt; char *, bool &gt;</code></td><td style="border-left-width: 0px"id="as_string_data"><div style="padding-left: 16px; text-indent: -16px"><code><b>as_string_data</b>(std::string * s)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">as_string_data(s) is equivalent to ({ char* p = mutable_string_data(s); make_pair(p, p != NULL); }) Sometimes it's faster: in some scenarios p cannot be NULL, and then the code can avoid that check. </div></td></tr></table> <hr><h3 id="mutable_string_data.details"><code>char * io::mutable_string_data(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * s)</code></h3><div style="margin-left: 16px"><p>Return a pointer to mutable characters underlying the given string. </p><p>The return value is valid until the next time the string is resized. We trust the caller to treat the return value as an array of length s-&gt;size(). </p>
</div><h2 id="ArrayInputStream">class ArrayInputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyInputStream">ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> backed by an in-memory array of bytes. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="ArrayInputStream.ArrayInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ArrayInputStream</b>(const void * data, int size, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create an InputStream that returns the bytes pointed to by "data".  <a href="#ArrayInputStream.ArrayInputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="ArrayInputStream.~ArrayInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~ArrayInputStream</b>()</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="ArrayInputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a chunk of data from the stream.  <a href="#ArrayInputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="ArrayInputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the next call to <a href='#ArrayInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#ArrayInputStream.Next'>Next()</a>.  <a href="#ArrayInputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="ArrayInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#ArrayInputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="ArrayInputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes read since this object was created. </div></td></tr></table> <hr><h3 id="ArrayInputStream.ArrayInputStream.details"><code> ArrayInputStream::ArrayInputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Create an InputStream that returns the bytes pointed to by "data". </p><p>"data" remains the property of the caller but must remain valid until the stream is destroyed. If a block_size is given, calls to <a href='#ArrayInputStream.Next'>Next()</a> will return data blocks no larger than the given size. Otherwise, the first call to <a href='#ArrayInputStream.Next'>Next()</a> returns the entire array. block_size is mainly useful for testing; in production you would probably never want to set it. </p>
</div> <hr><h3 id="ArrayInputStream.Next.details"><code>virtual bool ArrayInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a chunk of data from the stream. </p><p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#ArrayInputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="ArrayInputStream.BackUp.details"><code>virtual void ArrayInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the next call to <a href='#ArrayInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#ArrayInputStream.Next'>Next()</a>. </p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href='#ArrayInputStream.Next'>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href='#ArrayInputStream.BackUp'>BackUp()</a> to return to the point where you intended to finish.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#ArrayInputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#ArrayInputStream.Next'>Next()</a>.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#ArrayInputStream.Next'>Next()</a> will be pushed back into the stream. Subsequent calls to <a href='#ArrayInputStream.Next'>Next()</a> will return the same data again before producing new data. </li>
</ul>
</div> <hr><h3 id="ArrayInputStream.Skip.details"><code>virtual bool ArrayInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href='#ArrayInputStream.ByteCount'>ByteCount()</a> will return the total size of the stream). </p>
</div><h2 id="ArrayOutputStream">class ArrayOutputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream">ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> backed by an in-memory array of bytes. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="ArrayOutputStream.ArrayOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ArrayOutputStream</b>(void * data, int size, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create an OutputStream that writes to the bytes pointed to by "data".  <a href="#ArrayOutputStream.ArrayOutputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="ArrayOutputStream.~ArrayOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~ArrayOutputStream</b>()</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="ArrayOutputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a buffer into which data can be written.  <a href="#ArrayOutputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="ArrayOutputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the end of the last buffer returned by <a href='#ArrayOutputStream.Next'>Next()</a> is not actually written.  <a href="#ArrayOutputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="ArrayOutputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes written since this object was created. </div></td></tr></table> <hr><h3 id="ArrayOutputStream.ArrayOutputStream.details"><code> ArrayOutputStream::ArrayOutputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Create an OutputStream that writes to the bytes pointed to by "data". </p><p>"data" remains the property of the caller but must remain valid until the stream is destroyed. If a block_size is given, calls to <a href='#ArrayOutputStream.Next'>Next()</a> will return data blocks no larger than the given size. Otherwise, the first call to <a href='#ArrayOutputStream.Next'>Next()</a> returns the entire array. block_size is mainly useful for testing; in production you would probably never want to set it. </p>
</div> <hr><h3 id="ArrayOutputStream.Next.details"><code>virtual bool ArrayOutputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a buffer into which data can be written. </p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p>
<p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href='#ArrayOutputStream.BackUp'>BackUp()</a> is called).</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#ArrayOutputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="ArrayOutputStream.BackUp.details"><code>virtual void ArrayOutputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href='#ArrayOutputStream.Next'>Next()</a> is not actually written. </p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href='#ArrayOutputStream.BackUp'>BackUp()</a> to back up.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#ArrayOutputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#ArrayOutputStream.Next'>Next()</a>.</li>
  <li>The caller must not have written anything to the last "count" bytes of that buffer.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#ArrayOutputStream.Next'>Next()</a> will be ignored. </li>
</ul>
</div><h2 id="StringOutputStream">class StringOutputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream">ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which appends bytes to a string. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="StringOutputStream.StringOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>StringOutputStream</b>(std::string * target)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Create a <a href='#StringOutputStream'>StringOutputStream</a> which appends bytes to the given string.  <a href="#StringOutputStream.StringOutputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="StringOutputStream.~StringOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~StringOutputStream</b>()</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="StringOutputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a buffer into which data can be written.  <a href="#StringOutputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="StringOutputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the end of the last buffer returned by <a href='#StringOutputStream.Next'>Next()</a> is not actually written.  <a href="#StringOutputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="StringOutputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes written since this object was created. </div></td></tr></table> <hr><h3 id="StringOutputStream.StringOutputStream.details"><code>explicit  StringOutputStream::StringOutputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * target)</code></h3><div style="margin-left: 16px"><p>Create a <a href='#StringOutputStream'>StringOutputStream</a> which appends bytes to the given string. </p><p>The string remains property of the caller, but it is mutated in arbitrary ways and MUST NOT be accessed in any way until you're done with the stream. Either be sure there's no further usage, or (safest) destroy the stream before using the contents.</p>
<p>Hint: If you call target-&gt;reserve(n) before creating the stream, the first call to <a href='#StringOutputStream.Next'>Next()</a> will return at least n bytes of buffer space. </p>
</div> <hr><h3 id="StringOutputStream.Next.details"><code>virtual bool StringOutputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a buffer into which data can be written. </p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p>
<p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href='#StringOutputStream.BackUp'>BackUp()</a> is called).</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#StringOutputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="StringOutputStream.BackUp.details"><code>virtual void StringOutputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href='#StringOutputStream.Next'>Next()</a> is not actually written. </p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href='#StringOutputStream.BackUp'>BackUp()</a> to back up.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#StringOutputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#StringOutputStream.Next'>Next()</a>.</li>
  <li>The caller must not have written anything to the last "count" bytes of that buffer.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#StringOutputStream.Next'>Next()</a> will be ignored. </li>
</ul>
</div><h2 id="CopyingInputStream">class CopyingInputStream</h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A generic traditional input stream interface. </p><p>Lots of traditional input streams (e.g. file descriptors, C stdio streams, and C++ iostreams) expose an interface where every read involves copying bytes into a buffer. If you want to take such an interface and make a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> based on it, simply implement <a href='#CopyingInputStream'>CopyingInputStream</a> and then use <a href='#CopyingInputStreamAdaptor'>CopyingInputStreamAdaptor</a>.</p>
<p><a href='#CopyingInputStream'>CopyingInputStream</a> implementations should avoid buffering if possible. <a href='#CopyingInputStreamAdaptor'>CopyingInputStreamAdaptor</a> does its own buffering and will read data in large blocks. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="CopyingInputStream.~CopyingInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~CopyingInputStream</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int</code></td><td style="border-left-width: 0px"id="CopyingInputStream.Read"><div style="padding-left: 16px; text-indent: -16px"><code><b>Read</b>(void * buffer, int size)  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Reads up to "size" bytes into the given buffer.  <a href="#CopyingInputStream.Read.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int</code></td><td style="border-left-width: 0px"id="CopyingInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips the next "count" bytes of input.  <a href="#CopyingInputStream.Skip.details">more...</a></div></td></tr></table> <hr><h3 id="CopyingInputStream.Read.details"><code>virtual int CopyingInputStream::Read(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)  = 0</code></h3><div style="margin-left: 16px"><p>Reads up to "size" bytes into the given buffer. </p><p>Returns the number of bytes read. <a href='#CopyingInputStream.Read'>Read()</a> waits until at least one byte is available, or returns zero if no bytes will ever become available (EOF), or -1 if a permanent read error occurred. </p>
</div> <hr><h3 id="CopyingInputStream.Skip.details"><code>virtual int CopyingInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips the next "count" bytes of input. </p><p>Returns the number of bytes actually skipped. This will always be exactly equal to "count" unless EOF was reached or a permanent read error occurred.</p>
<p>The default implementation just repeatedly calls <a href='#CopyingInputStream.Read'>Read()</a> into a scratch buffer. </p>
</div><h2 id="CopyingInputStreamAdaptor">class CopyingInputStreamAdaptor: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyInputStream">ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from a <a href='#CopyingInputStream'>CopyingInputStream</a>. </p><p>This is useful for implementing ZeroCopyInputStreams that read from traditional streams. Note that this class is not really zero-copy.</p>
<p>If you want to read from file descriptors or C++ istreams, this is already implemented for you: use <a href='google.protobuf.io.zero_copy_stream_impl#FileInputStream'>FileInputStream</a> or <a href='google.protobuf.io.zero_copy_stream_impl#IstreamInputStream'>IstreamInputStream</a> respectively. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="CopyingInputStreamAdaptor.CopyingInputStreamAdaptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>CopyingInputStreamAdaptor</b>(<a href='#CopyingInputStream'>CopyingInputStream</a> * copying_stream, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Creates a stream that reads from the given <a href='#CopyingInputStream'>CopyingInputStream</a>.  <a href="#CopyingInputStreamAdaptor.CopyingInputStreamAdaptor.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CopyingInputStreamAdaptor.~CopyingInputStreamAdaptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>~CopyingInputStreamAdaptor</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CopyingInputStreamAdaptor.SetOwnsCopyingStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetOwnsCopyingStream</b>(bool value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Call SetOwnsCopyingStream(true) to tell the <a href='#CopyingInputStreamAdaptor'>CopyingInputStreamAdaptor</a> to delete the underlying <a href='#CopyingInputStream'>CopyingInputStream</a> when it is destroyed. </div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="CopyingInputStreamAdaptor.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a chunk of data from the stream.  <a href="#CopyingInputStreamAdaptor.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="CopyingInputStreamAdaptor.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the next call to <a href='#CopyingInputStreamAdaptor.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#CopyingInputStreamAdaptor.Next'>Next()</a>.  <a href="#CopyingInputStreamAdaptor.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="CopyingInputStreamAdaptor.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#CopyingInputStreamAdaptor.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="CopyingInputStreamAdaptor.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes read since this object was created. </div></td></tr></table> <hr><h3 id="CopyingInputStreamAdaptor.CopyingInputStreamAdaptor.details"><code>explicit  CopyingInputStreamAdaptor::CopyingInputStreamAdaptor(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CopyingInputStream'>CopyingInputStream</a> * copying_stream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Creates a stream that reads from the given <a href='#CopyingInputStream'>CopyingInputStream</a>. </p><p>If a block_size is given, it specifies the number of bytes that should be read and returned with each call to <a href='#CopyingInputStreamAdaptor.Next'>Next()</a>. Otherwise, a reasonable default is used. The caller retains ownership of copying_stream unless SetOwnsCopyingStream(true) is called. </p>
</div> <hr><h3 id="CopyingInputStreamAdaptor.Next.details"><code>virtual bool CopyingInputStreamAdaptor::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a chunk of data from the stream. </p><p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#CopyingInputStreamAdaptor.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="CopyingInputStreamAdaptor.BackUp.details"><code>virtual void CopyingInputStreamAdaptor::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the next call to <a href='#CopyingInputStreamAdaptor.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#CopyingInputStreamAdaptor.Next'>Next()</a>. </p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href='#CopyingInputStreamAdaptor.Next'>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href='#CopyingInputStreamAdaptor.BackUp'>BackUp()</a> to return to the point where you intended to finish.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#CopyingInputStreamAdaptor.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#CopyingInputStreamAdaptor.Next'>Next()</a>.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#CopyingInputStreamAdaptor.Next'>Next()</a> will be pushed back into the stream. Subsequent calls to <a href='#CopyingInputStreamAdaptor.Next'>Next()</a> will return the same data again before producing new data. </li>
</ul>
</div> <hr><h3 id="CopyingInputStreamAdaptor.Skip.details"><code>virtual bool CopyingInputStreamAdaptor::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href='#CopyingInputStreamAdaptor.ByteCount'>ByteCount()</a> will return the total size of the stream). </p>
</div><h2 id="CopyingOutputStream">class CopyingOutputStream</h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A generic traditional output stream interface. </p><p>Lots of traditional output streams (e.g. file descriptors, C stdio streams, and C++ iostreams) expose an interface where every write involves copying bytes from a buffer. If you want to take such an interface and make a <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> based on it, simply implement <a href='#CopyingOutputStream'>CopyingOutputStream</a> and then use <a href='#CopyingOutputStreamAdaptor'>CopyingOutputStreamAdaptor</a>.</p>
<p><a href='#CopyingOutputStream'>CopyingOutputStream</a> implementations should avoid buffering if possible. <a href='#CopyingOutputStreamAdaptor'>CopyingOutputStreamAdaptor</a> does its own buffering and will write data in large blocks. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual </code></td><td style="border-left-width: 0px"id="CopyingOutputStream.~CopyingOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~CopyingOutputStream</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="CopyingOutputStream.Write"><div style="padding-left: 16px; text-indent: -16px"><code><b>Write</b>(const void * buffer, int size)  = 0</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Writes "size" bytes from the given buffer to the output.  <a href="#CopyingOutputStream.Write.details">more...</a></div></td></tr></table> <hr><h3 id="CopyingOutputStream.Write.details"><code>virtual bool CopyingOutputStream::Write(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)  = 0</code></h3><div style="margin-left: 16px"><p>Writes "size" bytes from the given buffer to the output. </p><p>Returns true if successful, false on a write error. </p>
</div><h2 id="CopyingOutputStreamAdaptor">class CopyingOutputStreamAdaptor: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream">ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which writes to a <a href='#CopyingOutputStream'>CopyingOutputStream</a>. </p><p>This is useful for implementing ZeroCopyOutputStreams that write to traditional streams. Note that this class is not really zero-copy.</p>
<p>If you want to write to file descriptors or C++ ostreams, this is already implemented for you: use <a href='google.protobuf.io.zero_copy_stream_impl#FileOutputStream'>FileOutputStream</a> or <a href='google.protobuf.io.zero_copy_stream_impl#OstreamOutputStream'>OstreamOutputStream</a> respectively. </p>
<p>Known subclasses:</p><ul><li><code><a href="google.protobuf.io.zero_copy_stream_impl#FileOutputStream">FileOutputStream</a></code></li></ul><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.CopyingOutputStreamAdaptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>CopyingOutputStreamAdaptor</b>(<a href='#CopyingOutputStream'>CopyingOutputStream</a> * copying_stream, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Creates a stream that writes to the given Unix file descriptor.  <a href="#CopyingOutputStreamAdaptor.CopyingOutputStreamAdaptor.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.~CopyingOutputStreamAdaptor"><div style="padding-left: 16px; text-indent: -16px"><code><b>~CopyingOutputStreamAdaptor</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.Flush"><div style="padding-left: 16px; text-indent: -16px"><code><b>Flush</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Writes all pending data to the underlying stream.  <a href="#CopyingOutputStreamAdaptor.Flush.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.SetOwnsCopyingStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetOwnsCopyingStream</b>(bool value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Call SetOwnsCopyingStream(true) to tell the <a href='#CopyingOutputStreamAdaptor'>CopyingOutputStreamAdaptor</a> to delete the underlying <a href='#CopyingOutputStream'>CopyingOutputStream</a> when it is destroyed. </div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a buffer into which data can be written.  <a href="#CopyingOutputStreamAdaptor.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the end of the last buffer returned by <a href='#CopyingOutputStreamAdaptor.Next'>Next()</a> is not actually written.  <a href="#CopyingOutputStreamAdaptor.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes written since this object was created. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.WriteAliasedRaw"><div style="padding-left: 16px; text-indent: -16px"><code><b>WriteAliasedRaw</b>(const void * data, int size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Write a given chunk of data to the output.  <a href="#CopyingOutputStreamAdaptor.WriteAliasedRaw.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="CopyingOutputStreamAdaptor.AllowsAliasing"><div style="padding-left: 16px; text-indent: -16px"><code><b>AllowsAliasing</b>() const</code></div></td></tr></table> <hr><h3 id="CopyingOutputStreamAdaptor.CopyingOutputStreamAdaptor.details"><code>explicit  CopyingOutputStreamAdaptor::CopyingOutputStreamAdaptor(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#CopyingOutputStream'>CopyingOutputStream</a> * copying_stream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Creates a stream that writes to the given Unix file descriptor. </p><p>If a block_size is given, it specifies the size of the buffers that should be returned by <a href='#CopyingOutputStreamAdaptor.Next'>Next()</a>. Otherwise, a reasonable default is used. </p>
</div> <hr><h3 id="CopyingOutputStreamAdaptor.Flush.details"><code>bool CopyingOutputStreamAdaptor::Flush()</code></h3><div style="margin-left: 16px"><p>Writes all pending data to the underlying stream. </p><p>Returns false if a write error occurred on the underlying stream. (The underlying stream itself is not necessarily flushed.) </p>
</div> <hr><h3 id="CopyingOutputStreamAdaptor.Next.details"><code>virtual bool CopyingOutputStreamAdaptor::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a buffer into which data can be written. </p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p>
<p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href='#CopyingOutputStreamAdaptor.BackUp'>BackUp()</a> is called).</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#CopyingOutputStreamAdaptor.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="CopyingOutputStreamAdaptor.BackUp.details"><code>virtual void CopyingOutputStreamAdaptor::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href='#CopyingOutputStreamAdaptor.Next'>Next()</a> is not actually written. </p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href='#CopyingOutputStreamAdaptor.BackUp'>BackUp()</a> to back up.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#CopyingOutputStreamAdaptor.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#CopyingOutputStreamAdaptor.Next'>Next()</a>.</li>
  <li>The caller must not have written anything to the last "count" bytes of that buffer.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#CopyingOutputStreamAdaptor.Next'>Next()</a> will be ignored. </li>
</ul>
</div> <hr><h3 id="CopyingOutputStreamAdaptor.WriteAliasedRaw.details"><code>virtual bool CopyingOutputStreamAdaptor::WriteAliasedRaw(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style="margin-left: 16px"><p>Write a given chunk of data to the output. </p><p>Some output streams may implement this in a way that avoids copying. Check AllowsAliasing() before calling <a href='#CopyingOutputStreamAdaptor.WriteAliasedRaw'>WriteAliasedRaw()</a>. It will GOOGLE_CHECK fail if <a href='#CopyingOutputStreamAdaptor.WriteAliasedRaw'>WriteAliasedRaw()</a> is called on a stream that does not allow aliasing.</p>
<p>NOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream. </p>
</div><h2 id="LimitingInputStream">class LimitingInputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyInputStream">ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl_lite.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which wraps some other stream and limits it to a particular byte count. </p><table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="LimitingInputStream.LimitingInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>LimitingInputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> * input, int64 limit)</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="LimitingInputStream.~LimitingInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~LimitingInputStream</b>()</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="LimitingInputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a chunk of data from the stream.  <a href="#LimitingInputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="LimitingInputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the next call to <a href='#LimitingInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#LimitingInputStream.Next'>Next()</a>.  <a href="#LimitingInputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="LimitingInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#LimitingInputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="LimitingInputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes read since this object was created. </div></td></tr></table> <hr><h3 id="LimitingInputStream.Next.details"><code>virtual bool LimitingInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a chunk of data from the stream. </p><p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#LimitingInputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="LimitingInputStream.BackUp.details"><code>virtual void LimitingInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the next call to <a href='#LimitingInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#LimitingInputStream.Next'>Next()</a>. </p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href='#LimitingInputStream.Next'>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href='#LimitingInputStream.BackUp'>BackUp()</a> to return to the point where you intended to finish.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#LimitingInputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#LimitingInputStream.Next'>Next()</a>.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#LimitingInputStream.Next'>Next()</a> will be pushed back into the stream. Subsequent calls to <a href='#LimitingInputStream.Next'>Next()</a> will return the same data again before producing new data. </li>
</ul>
</div> <hr><h3 id="LimitingInputStream.Skip.details"><code>virtual bool LimitingInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href='#LimitingInputStream.ByteCount'>ByteCount()</a> will return the total size of the stream). </p>
</div>
