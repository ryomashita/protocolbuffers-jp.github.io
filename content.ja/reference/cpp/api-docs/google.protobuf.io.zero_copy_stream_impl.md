+++
title = "zero_copy_stream_impl.h"
toc_hide = "true"
linkTitle = "C++"
description = "This section contains reference documentation for working with protocol buffer classes in C++."
type = "docs"
+++

<p><code>#include &lt;google/protobuf/io/zero_copy_stream_impl.h&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>This file contains common implementations of the interfaces defined in <a href='google.protobuf.io.zero_copy_stream'>zero_copy_stream.h</a> which are only included in the full (non-lite) protobuf library. </p><p>These implementations include Unix file descriptors and C++ iostreams. See also: <a href='google.protobuf.io.zero_copy_stream_impl_lite'>zero_copy_stream_impl_lite.h</a> </p>

<table width="100%"><tr><th colspan="2"><h3 style="margin-top: 4px">Classes in this file</h3></th></tr><tr><td><div><code><a href="#FileInputStream">FileInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from a file descriptor. </div></td></tr><tr><td><div><code><a href="#FileOutputStream">FileOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which writes to a file descriptor. </div></td></tr><tr><td><div><code><a href="#IstreamInputStream">IstreamInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from a C++ istream. </div></td></tr><tr><td><div><code><a href="#OstreamOutputStream">OstreamOutputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which writes to a C++ ostream. </div></td></tr><tr><td><div><code><a href="#ConcatenatingInputStream">ConcatenatingInputStream</a></code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from several other streams in sequence. </div></td></tr></table><h2 id="FileInputStream">class FileInputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyInputStream">ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from a file descriptor. </p><p><a href='#FileInputStream'>FileInputStream</a> is preferred over using an ifstream with <a href='#IstreamInputStream'>IstreamInputStream</a>. The latter will introduce an extra layer of buffering, harming performance. Also, it's conceivable that <a href='#FileInputStream'>FileInputStream</a> could someday be enhanced to use zero-copy file descriptors on OSs which support them. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="FileInputStream.FileInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>FileInputStream</b>(int file_descriptor, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Creates a stream that reads from the given Unix file descriptor.  <a href="#FileInputStream.FileInputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="FileInputStream.Close"><div style="padding-left: 16px; text-indent: -16px"><code><b>Close</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Flushes any buffers and closes the underlying file.  <a href="#FileInputStream.Close.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="FileInputStream.SetCloseOnDelete"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetCloseOnDelete</b>(bool value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">By default, the file descriptor is not closed when the stream is destroyed.  <a href="#FileInputStream.SetCloseOnDelete.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="FileInputStream.GetErrno"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetErrno</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If an I/O error has occurred on this file descriptor, this is the errno from that error.  <a href="#FileInputStream.GetErrno.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="FileInputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a chunk of data from the stream.  <a href="#FileInputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="FileInputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the next call to <a href='#FileInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#FileInputStream.Next'>Next()</a>.  <a href="#FileInputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="FileInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#FileInputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="FileInputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes read since this object was created. </div></td></tr></table> <hr><h3 id="FileInputStream.FileInputStream.details"><code>explicit  FileInputStream::FileInputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int file_descriptor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Creates a stream that reads from the given Unix file descriptor. </p><p>If a block_size is given, it specifies the number of bytes that should be read and returned with each call to <a href='#FileInputStream.Next'>Next()</a>. Otherwise, a reasonable default is used. </p>
</div> <hr><h3 id="FileInputStream.Close.details"><code>bool FileInputStream::Close()</code></h3><div style="margin-left: 16px"><p>Flushes any buffers and closes the underlying file. </p><p>Returns false if an error occurs during the process; use <a href='#FileInputStream.GetErrno'>GetErrno()</a> to examine the error. Even if an error occurs, the file descriptor is closed when this returns. </p>
</div> <hr><h3 id="FileInputStream.SetCloseOnDelete.details"><code>void FileInputStream::SetCloseOnDelete(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool value)</code></h3><div style="margin-left: 16px"><p>By default, the file descriptor is not closed when the stream is destroyed. </p><p>Call SetCloseOnDelete(true) to change that. WARNING: This leaves no way for the caller to detect if close() fails. If detecting close() errors is important to you, you should arrange to close the descriptor yourself. </p>
</div> <hr><h3 id="FileInputStream.GetErrno.details"><code>int FileInputStream::GetErrno() const</code></h3><div style="margin-left: 16px"><p>If an I/O error has occurred on this file descriptor, this is the errno from that error. </p><p>Otherwise, this is zero. Once an error occurs, the stream is broken and all subsequent operations will fail. </p>
</div> <hr><h3 id="FileInputStream.Next.details"><code>virtual bool FileInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a chunk of data from the stream. </p><p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#FileInputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="FileInputStream.BackUp.details"><code>virtual void FileInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the next call to <a href='#FileInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#FileInputStream.Next'>Next()</a>. </p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href='#FileInputStream.Next'>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href='#FileInputStream.BackUp'>BackUp()</a> to return to the point where you intended to finish.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#FileInputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#FileInputStream.Next'>Next()</a>.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#FileInputStream.Next'>Next()</a> will be pushed back into the stream. Subsequent calls to <a href='#FileInputStream.Next'>Next()</a> will return the same data again before producing new data. </li>
</ul>
</div> <hr><h3 id="FileInputStream.Skip.details"><code>virtual bool FileInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href='#FileInputStream.ByteCount'>ByteCount()</a> will return the total size of the stream). </p>
</div><h2 id="FileOutputStream">class FileOutputStream: public <a href="google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor">CopyingOutputStreamAdaptor</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which writes to a file descriptor. </p><p><a href='#FileOutputStream'>FileOutputStream</a> is preferred over using an ofstream with <a href='#OstreamOutputStream'>OstreamOutputStream</a>. The latter will introduce an extra layer of buffering, harming performance. Also, it's conceivable that <a href='#FileOutputStream'>FileOutputStream</a> could someday be enhanced to use zero-copy file descriptors on OSs which support them. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="FileOutputStream.FileOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>FileOutputStream</b>(int file_descriptor, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Creates a stream that writes to the given Unix file descriptor.  <a href="#FileOutputStream.FileOutputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="FileOutputStream.~FileOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~FileOutputStream</b>()</code></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>bool</code></td><td style="border-left-width: 0px"id="FileOutputStream.Close"><div style="padding-left: 16px; text-indent: -16px"><code><b>Close</b>()</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Flushes any buffers and closes the underlying file.  <a href="#FileOutputStream.Close.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>void</code></td><td style="border-left-width: 0px"id="FileOutputStream.SetCloseOnDelete"><div style="padding-left: 16px; text-indent: -16px"><code><b>SetCloseOnDelete</b>(bool value)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">By default, the file descriptor is not closed when the stream is destroyed.  <a href="#FileOutputStream.SetCloseOnDelete.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>int</code></td><td style="border-left-width: 0px"id="FileOutputStream.GetErrno"><div style="padding-left: 16px; text-indent: -16px"><code><b>GetErrno</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">If an I/O error has occurred on this file descriptor, this is the errno from that error.  <a href="#FileOutputStream.GetErrno.details">more...</a></div></td></tr></table> <hr><h3 id="FileOutputStream.FileOutputStream.details"><code>explicit  FileOutputStream::FileOutputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int file_descriptor,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Creates a stream that writes to the given Unix file descriptor. </p><p>If a block_size is given, it specifies the size of the buffers that should be returned by <a href='google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next'>Next()</a>. Otherwise, a reasonable default is used. </p>
</div> <hr><h3 id="FileOutputStream.Close.details"><code>bool FileOutputStream::Close()</code></h3><div style="margin-left: 16px"><p>Flushes any buffers and closes the underlying file. </p><p>Returns false if an error occurs during the process; use <a href='#FileOutputStream.GetErrno'>GetErrno()</a> to examine the error. Even if an error occurs, the file descriptor is closed when this returns. </p>
</div> <hr><h3 id="FileOutputStream.SetCloseOnDelete.details"><code>void FileOutputStream::SetCloseOnDelete(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool value)</code></h3><div style="margin-left: 16px"><p>By default, the file descriptor is not closed when the stream is destroyed. </p><p>Call SetCloseOnDelete(true) to change that. WARNING: This leaves no way for the caller to detect if close() fails. If detecting close() errors is important to you, you should arrange to close the descriptor yourself. </p>
</div> <hr><h3 id="FileOutputStream.GetErrno.details"><code>int FileOutputStream::GetErrno() const</code></h3><div style="margin-left: 16px"><p>If an I/O error has occurred on this file descriptor, this is the errno from that error. </p><p>Otherwise, this is zero. Once an error occurs, the stream is broken and all subsequent operations will fail. </p>
</div><h2 id="IstreamInputStream">class IstreamInputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyInputStream">ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from a C++ istream. </p><p>Note that for reading files (or anything represented by a file descriptor), <a href='#FileInputStream'>FileInputStream</a> is more efficient. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="IstreamInputStream.IstreamInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>IstreamInputStream</b>(std::istream * stream, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Creates a stream that reads from the given C++ istream.  <a href="#IstreamInputStream.IstreamInputStream.details">more...</a></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="IstreamInputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a chunk of data from the stream.  <a href="#IstreamInputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="IstreamInputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the next call to <a href='#IstreamInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#IstreamInputStream.Next'>Next()</a>.  <a href="#IstreamInputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="IstreamInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#IstreamInputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="IstreamInputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes read since this object was created. </div></td></tr></table> <hr><h3 id="IstreamInputStream.IstreamInputStream.details"><code>explicit  IstreamInputStream::IstreamInputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::istream * stream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Creates a stream that reads from the given C++ istream. </p><p>If a block_size is given, it specifies the number of bytes that should be read and returned with each call to <a href='#IstreamInputStream.Next'>Next()</a>. Otherwise, a reasonable default is used. </p>
</div> <hr><h3 id="IstreamInputStream.Next.details"><code>virtual bool IstreamInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a chunk of data from the stream. </p><p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#IstreamInputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="IstreamInputStream.BackUp.details"><code>virtual void IstreamInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the next call to <a href='#IstreamInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#IstreamInputStream.Next'>Next()</a>. </p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href='#IstreamInputStream.Next'>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href='#IstreamInputStream.BackUp'>BackUp()</a> to return to the point where you intended to finish.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#IstreamInputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#IstreamInputStream.Next'>Next()</a>.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#IstreamInputStream.Next'>Next()</a> will be pushed back into the stream. Subsequent calls to <a href='#IstreamInputStream.Next'>Next()</a> will return the same data again before producing new data. </li>
</ul>
</div> <hr><h3 id="IstreamInputStream.Skip.details"><code>virtual bool IstreamInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href='#IstreamInputStream.ByteCount'>ByteCount()</a> will return the total size of the stream). </p>
</div><h2 id="OstreamOutputStream">class OstreamOutputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream">ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a> which writes to a C++ ostream. </p><p>Note that for writing files (or anything represented by a file descriptor), <a href='#FileOutputStream'>FileOutputStream</a> is more efficient. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>explicit </code></td><td style="border-left-width: 0px"id="OstreamOutputStream.OstreamOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>OstreamOutputStream</b>(std::ostream * stream, int block_size = -1)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Creates a stream that writes to the given C++ ostream.  <a href="#OstreamOutputStream.OstreamOutputStream.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="OstreamOutputStream.~OstreamOutputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~OstreamOutputStream</b>()</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream'>ZeroCopyOutputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="OstreamOutputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a buffer into which data can be written.  <a href="#OstreamOutputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="OstreamOutputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the end of the last buffer returned by <a href='#OstreamOutputStream.Next'>Next()</a> is not actually written.  <a href="#OstreamOutputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="OstreamOutputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes written since this object was created. </div></td></tr></table> <hr><h3 id="OstreamOutputStream.OstreamOutputStream.details"><code>explicit  OstreamOutputStream::OstreamOutputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::ostream * stream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style="margin-left: 16px"><p>Creates a stream that writes to the given C++ ostream. </p><p>If a block_size is given, it specifies the size of the buffers that should be returned by <a href='#OstreamOutputStream.Next'>Next()</a>. Otherwise, a reasonable default is used. </p>
</div> <hr><h3 id="OstreamOutputStream.Next.details"><code>virtual bool OstreamOutputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a buffer into which data can be written. </p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p>
<p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href='#OstreamOutputStream.BackUp'>BackUp()</a> is called).</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#OstreamOutputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="OstreamOutputStream.BackUp.details"><code>virtual void OstreamOutputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href='#OstreamOutputStream.Next'>Next()</a> is not actually written. </p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href='#OstreamOutputStream.BackUp'>BackUp()</a> to back up.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#OstreamOutputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#OstreamOutputStream.Next'>Next()</a>.</li>
  <li>The caller must not have written anything to the last "count" bytes of that buffer.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#OstreamOutputStream.Next'>Next()</a> will be ignored. </li>
</ul>
</div><h2 id="ConcatenatingInputStream">class ConcatenatingInputStream: public <a href="google.protobuf.io.zero_copy_stream#ZeroCopyInputStream">ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href="#">google/protobuf/io/zero_copy_stream_impl.h</a>&gt;<br>namespace <a href="#google.protobuf.io">google::protobuf::io</a></code></p><p>A <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> which reads from several other streams in sequence. </p><p><a href='#ConcatenatingInputStream'>ConcatenatingInputStream</a> is unable to distinguish between end-of-stream and read errors in the underlying streams, so it assumes any errors mean end-of-stream. So, if the underlying streams fail for any other reason, <a href='#ConcatenatingInputStream'>ConcatenatingInputStream</a> may do odd things. It is suggested that you do not use <a href='#ConcatenatingInputStream'>ConcatenatingInputStream</a> on streams that might produce read errors other than end-of-stream. </p>
<table><tr><th colspan="2"><h3 style="margin-top: 4px">Members</h3></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="ConcatenatingInputStream.ConcatenatingInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>ConcatenatingInputStream</b>(<a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a> *const streams, int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">All streams passed in as well as the array itself must remain valid until the <a href='#ConcatenatingInputStream'>ConcatenatingInputStream</a> is destroyed. </div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code></code></td><td style="border-left-width: 0px"id="ConcatenatingInputStream.~ConcatenatingInputStream"><div style="padding-left: 16px; text-indent: -16px"><code><b>~ConcatenatingInputStream</b>()</code></div></td></tr><tr><th colspan="2"><h3 style="margin-top: 4px; margin-bottom: 4px;">implements <a href='google.protobuf.io.zero_copy_stream#ZeroCopyInputStream'>ZeroCopyInputStream</a></h3><div style="font-style: italic; font-weight: normal;"></div></th></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="ConcatenatingInputStream.Next"><div style="padding-left: 16px; text-indent: -16px"><code><b>Next</b>(const void ** data, int * size)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Obtains a chunk of data from the stream.  <a href="#ConcatenatingInputStream.Next.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual void</code></td><td style="border-left-width: 0px"id="ConcatenatingInputStream.BackUp"><div style="padding-left: 16px; text-indent: -16px"><code><b>BackUp</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Backs up a number of bytes, so that the next call to <a href='#ConcatenatingInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#ConcatenatingInputStream.Next'>Next()</a>.  <a href="#ConcatenatingInputStream.BackUp.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual bool</code></td><td style="border-left-width: 0px"id="ConcatenatingInputStream.Skip"><div style="padding-left: 16px; text-indent: -16px"><code><b>Skip</b>(int count)</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Skips a number of bytes.  <a href="#ConcatenatingInputStream.Skip.details">more...</a></div></td></tr><tr><td style="border-right-width: 0px; text-align: right;"><code>virtual int64_t</code></td><td style="border-left-width: 0px"id="ConcatenatingInputStream.ByteCount"><div style="padding-left: 16px; text-indent: -16px"><code><b>ByteCount</b>() const</code></div><div style="font-style: italic; margin-top: 4px; margin-left: 16px;">Returns the total number of bytes read since this object was created. </div></td></tr></table> <hr><h3 id="ConcatenatingInputStream.Next.details"><code>virtual bool ConcatenatingInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style="margin-left: 16px"><p>Obtains a chunk of data from the stream. </p><p>Preconditions:</p>
<ul>
  <li>"size" and "data" are not NULL.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li>
  <li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li>
  <li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li>
  <li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href='#ConcatenatingInputStream.Next'>Next()</a> eventually yields a buffer with non-zero size. </li>
</ul>
</div> <hr><h3 id="ConcatenatingInputStream.BackUp.details"><code>virtual void ConcatenatingInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Backs up a number of bytes, so that the next call to <a href='#ConcatenatingInputStream.Next'>Next()</a> returns data again that was already returned by the last call to <a href='#ConcatenatingInputStream.Next'>Next()</a>. </p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href='#ConcatenatingInputStream.Next'>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href='#ConcatenatingInputStream.BackUp'>BackUp()</a> to return to the point where you intended to finish.</p>
<p>Preconditions:</p>
<ul>
  <li>The last method called must have been <a href='#ConcatenatingInputStream.Next'>Next()</a>.</li>
  <li>count must be less than or equal to the size of the last buffer returned by <a href='#ConcatenatingInputStream.Next'>Next()</a>.</li>
</ul>
<p>Postconditions:</p>
<ul>
  <li>The last "count" bytes of the last buffer returned by <a href='#ConcatenatingInputStream.Next'>Next()</a> will be pushed back into the stream. Subsequent calls to <a href='#ConcatenatingInputStream.Next'>Next()</a> will return the same data again before producing new data. </li>
</ul>
</div> <hr><h3 id="ConcatenatingInputStream.Skip.details"><code>virtual bool ConcatenatingInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style="margin-left: 16px"><p>Skips a number of bytes. </p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href='#ConcatenatingInputStream.ByteCount'>ByteCount()</a> will return the total size of the stream). </p>
</div>
