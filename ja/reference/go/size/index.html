<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=ja class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.121.2"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Protocol Buffers Documentation</title>
<meta name=description content="proto.Size 関数は、proto.Message のワイヤーフォーマットエンコーディングのサイズ（バイト単位）を返します。これは、すべてのフィールド（サブメッセージを含む）をトラバースして計算されます。
特に、これは Go Protobuf がメッセージをエンコードする方法のサイズ を返します。
典型的な使用法 空のメッセージの識別 proto.Size が 0 を返すかどうかをチェックすることは、空のメッセージを認識する簡単な方法です:
if proto.Size(m) == 0 { // No fields set (or, in proto3, all fields matching the default); // skip processing this message, or return an error, or similar. } サイズ制限付きのプログラム出力 別のシステムに作業タスクを生成するバッチ処理パイプラインを書いているとします。この例では、その別のシステムを「ダウンストリームシステム」と呼びます。ダウンストリームシステムは小〜中規模のタスクを処理するようにプロビジョニングされていますが、負荷テストでは、500 MB を超える作業タスクを提示するとシステムが連鎖的な障害に直面することがわかりました。
最善の修正方法は、ダウンストリームシステムに保護を追加することです（詳細は https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons を参照）。ただし、負荷分散を実装することが不可能な場合、パイプラインにクイックフィックスを追加することを決定することもできます:
func (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) { task := produceWorkTask(value) if proto.Size(task) &amp;gt; 100 * 1024 * 1024 { // Skip every work task over 100 MB to not overwhelm // the brittle downstream system."><meta property="og:title" content><meta property="og:description" content="proto.Size 関数は、proto.Message のワイヤーフォーマットエンコーディングのサイズ（バイト単位）を返します。これは、すべてのフィールド（サブメッセージを含む）をトラバースして計算されます。
特に、これは Go Protobuf がメッセージをエンコードする方法のサイズ を返します。
典型的な使用法 空のメッセージの識別 proto.Size が 0 を返すかどうかをチェックすることは、空のメッセージを認識する簡単な方法です:
if proto.Size(m) == 0 { // No fields set (or, in proto3, all fields matching the default); // skip processing this message, or return an error, or similar. } サイズ制限付きのプログラム出力 別のシステムに作業タスクを生成するバッチ処理パイプラインを書いているとします。この例では、その別のシステムを「ダウンストリームシステム」と呼びます。ダウンストリームシステムは小〜中規模のタスクを処理するようにプロビジョニングされていますが、負荷テストでは、500 MB を超える作業タスクを提示するとシステムが連鎖的な障害に直面することがわかりました。
最善の修正方法は、ダウンストリームシステムに保護を追加することです（詳細は https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons を参照）。ただし、負荷分散を実装することが不可能な場合、パイプラインにクイックフィックスを追加することを決定することもできます:
func (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) { task := produceWorkTask(value) if proto.Size(task) > 100 * 1024 * 1024 { // Skip every work task over 100 MB to not overwhelm // the brittle downstream system."><meta property="og:type" content="article"><meta property="og:url" content="https://protobuf.dev/ja/reference/go/size/"><meta property="article:section" content="reference"><meta itemprop=name content><meta itemprop=description content="proto.Size 関数は、proto.Message のワイヤーフォーマットエンコーディングのサイズ（バイト単位）を返します。これは、すべてのフィールド（サブメッセージを含む）をトラバースして計算されます。
特に、これは Go Protobuf がメッセージをエンコードする方法のサイズ を返します。
典型的な使用法 空のメッセージの識別 proto.Size が 0 を返すかどうかをチェックすることは、空のメッセージを認識する簡単な方法です:
if proto.Size(m) == 0 { // No fields set (or, in proto3, all fields matching the default); // skip processing this message, or return an error, or similar. } サイズ制限付きのプログラム出力 別のシステムに作業タスクを生成するバッチ処理パイプラインを書いているとします。この例では、その別のシステムを「ダウンストリームシステム」と呼びます。ダウンストリームシステムは小〜中規模のタスクを処理するようにプロビジョニングされていますが、負荷テストでは、500 MB を超える作業タスクを提示するとシステムが連鎖的な障害に直面することがわかりました。
最善の修正方法は、ダウンストリームシステムに保護を追加することです（詳細は https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons を参照）。ただし、負荷分散を実装することが不可能な場合、パイプラインにクイックフィックスを追加することを決定することもできます:
func (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) { task := produceWorkTask(value) if proto.Size(task) > 100 * 1024 * 1024 { // Skip every work task over 100 MB to not overwhelm // the brittle downstream system."><meta itemprop=wordCount content="306"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="proto.Size 関数は、proto.Message のワイヤーフォーマットエンコーディングのサイズ（バイト単位）を返します。これは、すべてのフィールド（サブメッセージを含む）をトラバースして計算されます。
特に、これは Go Protobuf がメッセージをエンコードする方法のサイズ を返します。
典型的な使用法 空のメッセージの識別 proto.Size が 0 を返すかどうかをチェックすることは、空のメッセージを認識する簡単な方法です:
if proto.Size(m) == 0 { // No fields set (or, in proto3, all fields matching the default); // skip processing this message, or return an error, or similar. } サイズ制限付きのプログラム出力 別のシステムに作業タスクを生成するバッチ処理パイプラインを書いているとします。この例では、その別のシステムを「ダウンストリームシステム」と呼びます。ダウンストリームシステムは小〜中規模のタスクを処理するようにプロビジョニングされていますが、負荷テストでは、500 MB を超える作業タスクを提示するとシステムが連鎖的な障害に直面することがわかりました。
最善の修正方法は、ダウンストリームシステムに保護を追加することです（詳細は https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons を参照）。ただし、負荷分散を実装することが不可能な場合、パイプラインにクイックフィックスを追加することを決定することもできます:
func (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) { task := produceWorkTask(value) if proto.Size(task) > 100 * 1024 * 1024 { // Skip every work task over 100 MB to not overwhelm // the brittle downstream system."><link rel=preload href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css as=style><link href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/ja/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Protocol Buffers Documentation</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item dropdown mr-4 d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/reference/go/size/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder=サイトを検索... aria-label=サイトを検索... autocomplete=off></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><p><a href=https://pkg.go.dev/google.golang.org/protobuf/proto#Size><code>proto.Size</code></a> 関数は、proto.Message のワイヤーフォーマットエンコーディングのサイズ（バイト単位）を返します。これは、すべてのフィールド（サブメッセージを含む）をトラバースして計算されます。</p><p>特に、これは <strong>Go Protobuf がメッセージをエンコードする方法のサイズ</strong> を返します。</p><h2 id=典型的な使用法>典型的な使用法</h2><h3 id=空のメッセージの識別>空のメッセージの識別</h3><p><a href=https://pkg.go.dev/google.golang.org/protobuf/proto#Size><code>proto.Size</code></a> が 0 を返すかどうかをチェックすることは、空のメッセージを認識する簡単な方法です:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>proto</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Size</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>m</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// No fields set (or, in proto3, all fields matching the default);
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// skip processing this message, or return an error, or similar.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h3 id=サイズ制限付きのプログラム出力>サイズ制限付きのプログラム出力</h3><p>別のシステムに作業タスクを生成するバッチ処理パイプラインを書いているとします。この例では、その別のシステムを「ダウンストリームシステム」と呼びます。ダウンストリームシステムは小〜中規模のタスクを処理するようにプロビジョニングされていますが、負荷テストでは、500 MB を超える作業タスクを提示するとシステムが連鎖的な障害に直面することがわかりました。</p><p>最善の修正方法は、ダウンストリームシステムに保護を追加することです（詳細は <a href=https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons>https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons</a> を参照）。ただし、負荷分散を実装することが不可能な場合、パイプラインにクイックフィックスを追加することを決定することもできます:</p><div class=highlight highlight=context:1,proto.Size,1><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>beamFn</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>ProcessElement</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>key</span> <span style=color:#204a87;font-weight:700>string</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>value</span> <span style=color:#000;font-weight:700>[]</span><span style=color:#204a87;font-weight:700>byte</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>emit</span> <span style=color:#204a87;font-weight:700>func</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>proto</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Message</span><span style=color:#000;font-weight:700>))</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>task</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000>produceWorkTask</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>value</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>proto</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Size</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>&gt;</span> <span style=color:#0000cf;font-weight:700>100</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#0000cf;font-weight:700>1024</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// Skip every work task over 100 MB to not overwhelm
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#8f5902;font-style:italic>// the brittle downstream system.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#204a87;font-weight:700>return</span>
</span></span><span style=display:flex><span>  <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>  <span style=color:#000>emit</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>task</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=誤った使用法-unmarshal-との関連がない>誤った使用法: Unmarshal との関連がない</h2><p><a href=https://pkg.go.dev/google.golang.org/protobuf/proto#Size><code>proto.Size</code></a> は、Go Protobuf がメッセージをエンコードする方法のバイト数を返すため、入力された Protobuf メッセージのストリームをアンマーシャリング（デコード）する際に <code>proto.Size</code> を使用することは安全ではありません:</p><div class=highlight highlight=context:1,proto.Size,1><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#204a87;font-weight:700>func</span> <span style=color:#000>bytesToSubscriptionList</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>data</span> <span style=color:#000;font-weight:700>[]</span><span style=color:#204a87;font-weight:700>byte</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>([]</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>vpb</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>EventSubscription</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>error</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#000>subList</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000;font-weight:700>[]</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>vpb</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>EventSubscription</span><span style=color:#000;font-weight:700>{}</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>for</span> <span style=color:#204a87>len</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>data</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>&gt;</span> <span style=color:#0000cf;font-weight:700>0</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#000>subscription</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>vpb</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>EventSubscription</span><span style=color:#000;font-weight:700>{}</span>
</span></span><span style=display:flex><span>        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>err</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000>proto</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Unmarshal</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>data</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>subscription</span><span style=color:#000;font-weight:700>);</span> <span style=color:#000>err</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#204a87;font-weight:700>nil</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#204a87;font-weight:700>nil</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>err</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#000>subList</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#204a87>append</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>subList</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>subscription</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        <span style=color:#000>data</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>data</span><span style=color:#000;font-weight:700>[:</span><span style=color:#204a87>len</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>data</span><span style=color:#000;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>proto</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Size</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>subscription</span><span style=color:#000;font-weight:700>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>subList</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>nil</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p><code>data</code> が <a href=#non-minimal>非最小ワイヤーフォーマット</a> のメッセージを含む場合、<code>proto.Size</code> は実際にアンマーシャリングされたサイズと異なるサイズを返す可能性があり、解析エラー（最善の場合）または最悪の場合は誤って解析されたデータが発生します。</p><p>したがって、この例は、すべての入力メッセージが（同じバージョンの）Go Protobufによって生成された限りにおいてのみ信頼性があります。これは驚くべきことであり、おそらく意図されていないものです。</p><p><strong>ヒント:</strong>
<a href=https://pkg.go.dev/google.golang.org/protobuf/encoding/protodelim><code>protodelim</code> パッケージ</a>
を使用して、Protobuf メッセージのサイズ区切りストリームを読み書きすることができます。</p><h2 id=高度な使用法-バッファの事前サイズ指定>高度な使用法: バッファの事前サイズ指定</h2><p><a href=https://pkg.go.dev/google.golang.org/protobuf/proto#Size><code>proto.Size</code></a> の高度な使用法は、マーシャリング前にバッファに必要なサイズを決定することです:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000>opts</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000>proto</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>MarshalOptions</span><span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8f5902;font-style:italic>// Possibly avoid an extra proto.Size in Marshal itself (see docs):
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>    <span style=color:#000>UseCachedSize</span><span style=color:#000;font-weight:700>:</span> <span style=color:#204a87;font-weight:700>true</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// DO NOT SUBMIT without implementing this Optimization opportunity:
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// instead of allocating, grab a sufficiently-sized buffer from a pool.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Knowing the size of the buffer means we can discard
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// outliers from the pool to prevent uncontrolled
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// memory growth in long-running RPC services.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>buf</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#204a87>make</span><span style=color:#000;font-weight:700>([]</span><span style=color:#204a87;font-weight:700>byte</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>opts</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Size</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>m</span><span style=color:#000;font-weight:700>))</span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>var</span> <span style=color:#000>err</span> <span style=color:#204a87;font-weight:700>error</span>
</span></span><span style=display:flex><span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>err</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#000>opts</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>MarshalAppend</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>m</span><span style=color:#000;font-weight:700>)</span> <span style=color:#8f5902;font-style:italic>// does not allocate
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic>// Note that len(buf) might be less than cap(buf)! Read below:
</span></span></span></code></pre></div><p>遅延デコードが有効になっている場合、<code>proto.Size</code> は <code>proto.Marshal</code>（および <code>proto.MarshalAppend</code> のような変種）が書き込るよりも多くのバイトを返す可能性があります！そのため、エンコードされたバイトをワイヤー（またはディスク）に配置する場合は、<code>len(buf)</code> で作業し、以前の <code>proto.Size</code> の結果を破棄してください。</p><p>具体的には、(サブ-)メッセージは <code>proto.Size</code> と <code>proto.Marshal</code> の間で「縮小」する可能性があります:</p><ol><li>遅延デコードが有効になっている</li><li>メッセージが <a href=#non-minimal>非最小ワイヤー形式</a> で到着している</li><li><code>proto.Size</code> が呼び出される前にメッセージがアクセスされていないため、まだデコードされていない</li><li><code>proto.Size</code> の後（ただし <code>proto.Marshal</code> の前）にメッセージがアクセスされ、それによって遅延デコードされる</li></ol><p>デコードにより、後続の <code>proto.Marshal</code> 呼び出しはメッセージをエンコードし（単にワイヤー形式をコピーするのではなく）、Go がメッセージをエンコードする方法に暗黙的に正規化され、現在は最小のワイヤー形式になります（ただし、それに依存しないでください！）。</p><p>このシナリオはかなり特定されていることがわかりますが、それでも <strong><code>proto.Size</code> の結果を上限として扱い、実際にエンコードされたメッセージのサイズと一致するとは決して仮定しない</strong> のが最善の方法です。</p><h2 id=non-minimal>背景: 非最小ワイヤー形式</h2><p>Protobuf メッセージをエンコードする際、1 つの <em>最小ワイヤー形式サイズ</em> と、同じメッセージにデコードされる複数の大きな <em>非最小ワイヤー形式</em> があります。</p><p>非最小ワイヤー形式（時には「非正規化ワイヤー形式」とも呼ばれる）は、非繰り返しフィールドが複数回現れる、最適でない varint エンコーディング、ワイヤー上で非パックされたように見えるパックされた繰り返しフィールドなどのシナリオを指します。</p><p>異なるシナリオで非最小のワイヤ形式に遭遇することがあります：</p><ul><li><strong>意図的に。</strong> Protobuf は、メッセージを連結してワイヤ形式を連結することをサポートしています。</li><li><strong>偶然に。</strong> （おそらくサードパーティの）Protobuf エンコーダが理想的にエンコードされない場合（例：varint をエンコードする際に必要以上のスペースを使用する場合）。</li><li><strong>悪意を持って。</strong> 攻撃者は、ネットワーク上でクラッシュを引き起こすために特定の Protobuf メッセージを作成する可能性があります。</li></ul></main><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2024 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>プライバシーポリシー</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/js/main.min.ba08a6b7f24e657f0a1b9b55be3a3162585168cd862ace0957f5b44e6cb6dc61.js integrity="sha256-ugimt/JOZX8KG5tVvjoxYlhRaM2GKs4JV/W0Tmy23GE=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>