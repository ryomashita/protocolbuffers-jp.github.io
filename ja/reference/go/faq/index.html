<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=ja class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.121.2"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Protocol Buffers Documentation</title>
<meta name=description content="バージョン github.com/golang/protobuf と google.golang.org/protobuf の違いは何ですか？ github.com/golang/protobuf モジュールは、元のGoプロトコルバッファAPIです。
google.golang.org/protobuf モジュールは、このAPIの更新版であり、シンプルさ、使いやすさ、安全性を考慮して設計されています。更新されたAPIの主要な機能は、リフレクションのサポートと、ユーザー向けAPIと基礎実装の分離です。
新しいコードでは google.golang.org/protobuf を使用することを推奨します。
github.com/golang/protobuf のバージョン v1.4.0 以降は、新しい実装をラップし、プログラムが新しいAPIを段階的に採用できるようにします。たとえば、github.com/golang/protobuf/ptypes で定義された well-known types は、単に新しいモジュールで定義されたもののエイリアスです。したがって、google.golang.org/protobuf/types/known/emptypb と github.com/golang/protobuf/ptypes/empty は互換性があります。
proto1、proto2、proto3 とは何ですか？ これらはプロトコルバッファの 言語 のリビジョンです。これは、Goのプロトコルバッファの 実装 とは異なります。
proto3 は現在の言語のバージョンです。これは最も一般的に使用される言語のバージョンです。新しいコードでは proto3 を使用することを推奨します。
proto2 は古い言語のバージョンです。proto3 に置き換えられましたが、proto2 は完全にサポートされています。
proto1 は古い言語のバージョンであり、オープンソースとしてリリースされたことはありません。
いくつかの異なる Message タイプがあります。どれを使用すべきですか？ &amp;quot;google.golang.org/protobuf/proto&amp;quot;.Message は、現在のプロトコルバッファコンパイラによって生成されたすべてのメッセージによって実装されるインターフェース型です。proto.Marshal や proto.Clone など、任意のメッセージに対して操作を行う関数は、この型を受け入れるか返します。
&amp;quot;google.golang.org/protobuf/reflect/protoreflect&amp;quot;.Message は、メッセージの反射ビューを記述するインターフェース型です。
proto.Message 上で ProtoReflect メソッドを呼び出すと、protoreflect.Message を取得できます。
&amp;quot;google.golang.org/protobuf/reflect/protoreflect&amp;quot;.ProtoMessage は、&amp;quot;google.golang.org/protobuf/proto&amp;quot;.Message のエイリアスです。これらの2つの型は互換性があります。
&amp;quot;github.com/golang/protobuf/proto&amp;quot;.Message は、古い Go プロトコルバッファ API で定義されたインターフェース型です。すべての生成されたメッセージ型はこのインターフェースを実装しますが、このインターフェースはこれらのメッセージから期待される動作を記述していません。新しいコードではこの型の使用を避けるべきです。
一般的な問題 &amp;ldquo;go install&amp;rdquo;: working directory is not part of a module Go 1."><meta property="og:title" content><meta property="og:description" content="バージョン github.com/golang/protobuf と google.golang.org/protobuf の違いは何ですか？ github.com/golang/protobuf モジュールは、元のGoプロトコルバッファAPIです。
google.golang.org/protobuf モジュールは、このAPIの更新版であり、シンプルさ、使いやすさ、安全性を考慮して設計されています。更新されたAPIの主要な機能は、リフレクションのサポートと、ユーザー向けAPIと基礎実装の分離です。
新しいコードでは google.golang.org/protobuf を使用することを推奨します。
github.com/golang/protobuf のバージョン v1.4.0 以降は、新しい実装をラップし、プログラムが新しいAPIを段階的に採用できるようにします。たとえば、github.com/golang/protobuf/ptypes で定義された well-known types は、単に新しいモジュールで定義されたもののエイリアスです。したがって、google.golang.org/protobuf/types/known/emptypb と github.com/golang/protobuf/ptypes/empty は互換性があります。
proto1、proto2、proto3 とは何ですか？ これらはプロトコルバッファの 言語 のリビジョンです。これは、Goのプロトコルバッファの 実装 とは異なります。
proto3 は現在の言語のバージョンです。これは最も一般的に使用される言語のバージョンです。新しいコードでは proto3 を使用することを推奨します。
proto2 は古い言語のバージョンです。proto3 に置き換えられましたが、proto2 は完全にサポートされています。
proto1 は古い言語のバージョンであり、オープンソースとしてリリースされたことはありません。
いくつかの異なる Message タイプがあります。どれを使用すべきですか？ &#34;google.golang.org/protobuf/proto&#34;.Message は、現在のプロトコルバッファコンパイラによって生成されたすべてのメッセージによって実装されるインターフェース型です。proto.Marshal や proto.Clone など、任意のメッセージに対して操作を行う関数は、この型を受け入れるか返します。
&#34;google.golang.org/protobuf/reflect/protoreflect&#34;.Message は、メッセージの反射ビューを記述するインターフェース型です。
proto.Message 上で ProtoReflect メソッドを呼び出すと、protoreflect.Message を取得できます。
&#34;google.golang.org/protobuf/reflect/protoreflect&#34;.ProtoMessage は、&#34;google.golang.org/protobuf/proto&#34;.Message のエイリアスです。これらの2つの型は互換性があります。
&#34;github.com/golang/protobuf/proto&#34;.Message は、古い Go プロトコルバッファ API で定義されたインターフェース型です。すべての生成されたメッセージ型はこのインターフェースを実装しますが、このインターフェースはこれらのメッセージから期待される動作を記述していません。新しいコードではこの型の使用を避けるべきです。
一般的な問題 &ldquo;go install&rdquo;: working directory is not part of a module Go 1."><meta property="og:type" content="article"><meta property="og:url" content="https://protobuf.dev/ja/reference/go/faq/"><meta property="article:section" content="reference"><meta itemprop=name content><meta itemprop=description content="バージョン github.com/golang/protobuf と google.golang.org/protobuf の違いは何ですか？ github.com/golang/protobuf モジュールは、元のGoプロトコルバッファAPIです。
google.golang.org/protobuf モジュールは、このAPIの更新版であり、シンプルさ、使いやすさ、安全性を考慮して設計されています。更新されたAPIの主要な機能は、リフレクションのサポートと、ユーザー向けAPIと基礎実装の分離です。
新しいコードでは google.golang.org/protobuf を使用することを推奨します。
github.com/golang/protobuf のバージョン v1.4.0 以降は、新しい実装をラップし、プログラムが新しいAPIを段階的に採用できるようにします。たとえば、github.com/golang/protobuf/ptypes で定義された well-known types は、単に新しいモジュールで定義されたもののエイリアスです。したがって、google.golang.org/protobuf/types/known/emptypb と github.com/golang/protobuf/ptypes/empty は互換性があります。
proto1、proto2、proto3 とは何ですか？ これらはプロトコルバッファの 言語 のリビジョンです。これは、Goのプロトコルバッファの 実装 とは異なります。
proto3 は現在の言語のバージョンです。これは最も一般的に使用される言語のバージョンです。新しいコードでは proto3 を使用することを推奨します。
proto2 は古い言語のバージョンです。proto3 に置き換えられましたが、proto2 は完全にサポートされています。
proto1 は古い言語のバージョンであり、オープンソースとしてリリースされたことはありません。
いくつかの異なる Message タイプがあります。どれを使用すべきですか？ &#34;google.golang.org/protobuf/proto&#34;.Message は、現在のプロトコルバッファコンパイラによって生成されたすべてのメッセージによって実装されるインターフェース型です。proto.Marshal や proto.Clone など、任意のメッセージに対して操作を行う関数は、この型を受け入れるか返します。
&#34;google.golang.org/protobuf/reflect/protoreflect&#34;.Message は、メッセージの反射ビューを記述するインターフェース型です。
proto.Message 上で ProtoReflect メソッドを呼び出すと、protoreflect.Message を取得できます。
&#34;google.golang.org/protobuf/reflect/protoreflect&#34;.ProtoMessage は、&#34;google.golang.org/protobuf/proto&#34;.Message のエイリアスです。これらの2つの型は互換性があります。
&#34;github.com/golang/protobuf/proto&#34;.Message は、古い Go プロトコルバッファ API で定義されたインターフェース型です。すべての生成されたメッセージ型はこのインターフェースを実装しますが、このインターフェースはこれらのメッセージから期待される動作を記述していません。新しいコードではこの型の使用を避けるべきです。
一般的な問題 &ldquo;go install&rdquo;: working directory is not part of a module Go 1."><meta itemprop=wordCount content="287"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="バージョン github.com/golang/protobuf と google.golang.org/protobuf の違いは何ですか？ github.com/golang/protobuf モジュールは、元のGoプロトコルバッファAPIです。
google.golang.org/protobuf モジュールは、このAPIの更新版であり、シンプルさ、使いやすさ、安全性を考慮して設計されています。更新されたAPIの主要な機能は、リフレクションのサポートと、ユーザー向けAPIと基礎実装の分離です。
新しいコードでは google.golang.org/protobuf を使用することを推奨します。
github.com/golang/protobuf のバージョン v1.4.0 以降は、新しい実装をラップし、プログラムが新しいAPIを段階的に採用できるようにします。たとえば、github.com/golang/protobuf/ptypes で定義された well-known types は、単に新しいモジュールで定義されたもののエイリアスです。したがって、google.golang.org/protobuf/types/known/emptypb と github.com/golang/protobuf/ptypes/empty は互換性があります。
proto1、proto2、proto3 とは何ですか？ これらはプロトコルバッファの 言語 のリビジョンです。これは、Goのプロトコルバッファの 実装 とは異なります。
proto3 は現在の言語のバージョンです。これは最も一般的に使用される言語のバージョンです。新しいコードでは proto3 を使用することを推奨します。
proto2 は古い言語のバージョンです。proto3 に置き換えられましたが、proto2 は完全にサポートされています。
proto1 は古い言語のバージョンであり、オープンソースとしてリリースされたことはありません。
いくつかの異なる Message タイプがあります。どれを使用すべきですか？ &#34;google.golang.org/protobuf/proto&#34;.Message は、現在のプロトコルバッファコンパイラによって生成されたすべてのメッセージによって実装されるインターフェース型です。proto.Marshal や proto.Clone など、任意のメッセージに対して操作を行う関数は、この型を受け入れるか返します。
&#34;google.golang.org/protobuf/reflect/protoreflect&#34;.Message は、メッセージの反射ビューを記述するインターフェース型です。
proto.Message 上で ProtoReflect メソッドを呼び出すと、protoreflect.Message を取得できます。
&#34;google.golang.org/protobuf/reflect/protoreflect&#34;.ProtoMessage は、&#34;google.golang.org/protobuf/proto&#34;.Message のエイリアスです。これらの2つの型は互換性があります。
&#34;github.com/golang/protobuf/proto&#34;.Message は、古い Go プロトコルバッファ API で定義されたインターフェース型です。すべての生成されたメッセージ型はこのインターフェースを実装しますが、このインターフェースはこれらのメッセージから期待される動作を記述していません。新しいコードではこの型の使用を避けるべきです。
一般的な問題 &ldquo;go install&rdquo;: working directory is not part of a module Go 1."><link rel=preload href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css as=style><link href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/ja/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Protocol Buffers Documentation</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item dropdown mr-4 d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/reference/go/faq/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder=サイトを検索... aria-label=サイトを検索... autocomplete=off></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><h2 id=バージョン>バージョン</h2><h3 id=modules><code>github.com/golang/protobuf</code> と <code>google.golang.org/protobuf</code> の違いは何ですか？</h3><p><a href="https://pkg.go.dev/github.com/golang/protobuf?tab=overview"><code>github.com/golang/protobuf</code></a> モジュールは、元のGoプロトコルバッファAPIです。</p><p><a href="https://pkg.go.dev/google.golang.org/protobuf?tab=overview"><code>google.golang.org/protobuf</code></a> モジュールは、このAPIの更新版であり、シンプルさ、使いやすさ、安全性を考慮して設計されています。更新されたAPIの主要な機能は、リフレクションのサポートと、ユーザー向けAPIと基礎実装の分離です。</p><p>新しいコードでは <code>google.golang.org/protobuf</code> を使用することを推奨します。</p><p><code>github.com/golang/protobuf</code> のバージョン <code>v1.4.0</code> 以降は、新しい実装をラップし、プログラムが新しいAPIを段階的に採用できるようにします。たとえば、<code>github.com/golang/protobuf/ptypes</code> で定義された well-known types は、単に新しいモジュールで定義されたもののエイリアスです。したがって、<a href=https://pkg.go.dev/google.golang.org/protobuf/types/known/emptypb><code>google.golang.org/protobuf/types/known/emptypb</code></a> と <a href=https://pkg.go.dev/github.com/golang/protobuf/ptypes/empty><code>github.com/golang/protobuf/ptypes/empty</code></a> は互換性があります。</p><h3 id=proto-versions><code>proto1</code>、<code>proto2</code>、<code>proto3</code> とは何ですか？</h3><p>これらはプロトコルバッファの <em>言語</em> のリビジョンです。これは、Goのプロトコルバッファの <em>実装</em> とは異なります。</p><ul><li><p><code>proto3</code> は現在の言語のバージョンです。これは最も一般的に使用される言語のバージョンです。新しいコードでは proto3 を使用することを推奨します。</p></li><li><p><code>proto2</code> は古い言語のバージョンです。proto3 に置き換えられましたが、proto2 は完全にサポートされています。</p></li><li><p><code>proto1</code> は古い言語のバージョンであり、オープンソースとしてリリースされたことはありません。</p></li></ul><h3 id=message-types>いくつかの異なる <code>Message</code> タイプがあります。どれを使用すべきですか？</h3><ul><li><p><a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Message"><code>"google.golang.org/protobuf/proto".Message</code></a> は、現在のプロトコルバッファコンパイラによって生成されたすべてのメッセージによって実装されるインターフェース型です。<a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal"><code>proto.Marshal</code></a> や <a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Clone"><code>proto.Clone</code></a> など、任意のメッセージに対して操作を行う関数は、この型を受け入れるか返します。</p></li><li><p><a href="https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Message"><code>"google.golang.org/protobuf/reflect/protoreflect".Message</code></a>
は、メッセージの反射ビューを記述するインターフェース型です。</p><p><code>proto.Message</code> 上で <code>ProtoReflect</code> メソッドを呼び出すと、<code>protoreflect.Message</code> を取得できます。</p></li><li><p><a href="https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#ProtoMessage"><code>"google.golang.org/protobuf/reflect/protoreflect".ProtoMessage</code></a>
は、<code>"google.golang.org/protobuf/proto".Message</code> のエイリアスです。これらの2つの型は互換性があります。</p></li><li><p><a href="https://pkg.go.dev/github.com/golang/protobuf/proto?tab=doc#Message"><code>"github.com/golang/protobuf/proto".Message</code></a>
は、古い Go プロトコルバッファ API で定義されたインターフェース型です。すべての生成されたメッセージ型はこのインターフェースを実装しますが、このインターフェースはこれらのメッセージから期待される動作を記述していません。新しいコードではこの型の使用を避けるべきです。</p></li></ul><h2 id=一般的な問題>一般的な問題</h2><h3 id=working-directory>&ldquo;<code>go install</code>&rdquo;: <code>working directory is not part of a module</code></h3><p>Go 1.15 以前では、環境変数 <code>GO111MODULE=on</code> を設定し、<code>go install</code> コマンドをモジュールディレクトリの外で実行しています。<code>GO111MODULE=auto</code> を設定するか、環境変数をアンセットしてください。</p><p>Go 1.16 以降では、明示的なバージョンを指定してモジュールの外で <code>go install</code> を実行できます: <code>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</code></p><h3 id=enforce-version><code>constant -1 overflows protoimpl.EnforceVersion</code></h3><p>新しいバージョンの <code>"google.golang.org/protobuf"</code> モジュールが必要な生成された <code>.pb.go</code> ファイルを使用しています。</p><p>次のコマンドで新しいバージョンに更新してください:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get -u google.golang.org/protobuf/proto
</span></span></code></pre></div><h3 id=enforce-version-apiv1><code>undefined: "github.com/golang/protobuf/proto".ProtoPackageIsVersion4</code></h3><p>新しいバージョンの <code>"github.com/golang/protobuf"</code> モジュールが必要な生成された <code>.pb.go</code> ファイルを使用しています。</p><p>次のコマンドで新しいバージョンに更新してください:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get -u github.com/golang/protobuf/proto
</span></span></code></pre></div><h3 id=namespace-conflict>プロトコルバッファの名前空間の競合とは何ですか？</h3><p>すべてのプロトコルバッファ宣言は、Goバイナリにリンクされたグローバルレジストリに挿入されます。</p><p>すべてのプロトコルバッファ宣言（たとえば、列挙型、列挙値、またはメッセージ）には、絶対名があります。これは、<a href=/programming-guides/proto2#packages>パッケージ名</a>と<code>.proto</code>ソースファイル内の宣言の相対名の連結です（たとえば、<code>my.proto.package.MyMessage.NestedMessage</code>）。プロトコルバッファ言語は、すべての宣言が普遍的に一意であると想定しています。</p><p>Goバイナリにリンクされた2つのプロトコルバッファ宣言が同じ名前を持つ場合、これは名前空間の競合を引き起こし、レジストリがその宣言を名前で適切に解決することが不可能です。使用されているGo protobufsのバージョンに応じて、これは初期化時にパニックを引き起こすか、競合を無視してランタイム中に潜在的なバグを引き起こす可能性があります。</p><h3 id=fix-namespace-conflict>プロトコルバッファの名前空間の競合を修正するには？</h3><p>名前空間の競合を最良に修正する方法は、競合が発生している理由によって異なります。</p><p>名前空間の競合が発生する一般的な方法：</p><ul><li><p><strong>ベンダー提供の.protoファイル。</strong> 1つの<code>.proto</code>ファイルが2つ以上のGoパッケージに生成され、同じGoバイナリにリンクされると、生成されたGoパッケージ内のすべてのプロトコルバッファ宣言で競合が発生します。これは通常、<code>.proto</code>ファイルがベンダリングされ、それからGoパッケージが生成される場合、または生成されたGoパッケージ自体がベンダリングされる場合に発生します。ユーザーはベンダリングを避け、その<code>.proto</code>ファイルに対して集中化されたGoパッケージに依存することをお勧めします。</p><ul><li>もし<code>.proto</code>ファイルが外部の団体によって所有されており、<code>go_package</code>オプションが欠けている場合、その<code>.proto</code>ファイルの所有者と協力して、複数のユーザーが依存できる集中化されたGoパッケージを指定するようにする必要があります。</li></ul></li><li><p><strong>欠落または一般的なprotoパッケージ名。</strong> もし<code>.proto</code>ファイルがパッケージ名を指定していないか、あるいは非常に一般的なパッケージ名を使用している場合（たとえば、&ldquo;my_service"など）、そのファイル内の宣言が他の場所での宣言と競合する可能性が高いです。私たちは、すべての<code>.proto</code>ファイルに、普遍的に一意であるように故意に選択されたパッケージ名があることをお勧めします（たとえば、会社名で接頭辞を付けるなど）。</p><ul><li><strong>警告:</strong> <code>.proto</code> ファイルでパッケージ名を後から変更すると、拡張フィールドとして使用される型、<code>google.protobuf.Any</code> に格納される型、または gRPC サービス定義に対して後方互換性がありません。</li></ul></li></ul><p>Starting with v1.26.0 of the <code>google.golang.org/protobuf</code> module, a hard error
will be reported when a Go program starts up that has multiple conflicting
protobuf names linked into it. While it is preferable that the source of the
conflict be fixed, the fatal error can be immediately worked around in one of
two ways:</p><ol><li><p><strong>コンパイル時に。</strong> 衝突の処理方法のデフォルト動作は、リンカー初期化変数を使用してコンパイル時に指定できます: <code>go build -ldflags "-X google.golang.org/protobuf/reflect/protoregistry.conflictPolicy=warn"</code></p></li><li><p><strong>プログラムの実行時に。</strong> 特定の Go バイナリを実行する際の衝突の処理方法は、環境変数を使用して設定できます: <code>GOLANG_PROTOBUF_REGISTRATION_CONFLICT=warn ./main</code></p></li></ol><h3 id=deepequal><code>reflect.DeepEqual</code> はなぜ protobuf メッセージで予期しない動作をするのですか？</h3><p>生成されたプロトコルバッファメッセージ型には、同等のメッセージ間でも異なる内部状態が含まれることがあります。</p><p>さらに、<code>reflect.DeepEqual</code> 関数はプロトコルバッファメッセージのセマンティクスを認識しておらず、存在しない差異を報告することがあります。たとえば、<code>nil</code> マップを含むフィールドと、ゼロ長で非 <code>nil</code> マップを含むフィールドはセマンティック的に等価ですが、<code>reflect.DeepEqual</code> では等しくないと報告されます。</p><p>メッセージの値を比較するには、<a href=https://pkg.go.dev/google.golang.org/protobuf/proto#Equal><code>proto.Equal</code></a> 関数を使用してください。</p><p>テストでは、<a href="https://pkg.go.dev/github.com/google/go-cmp/cmp?tab=doc"><code>"github.com/google/go-cmp/cmp"</code></a> パッケージを使用して、<a href=https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp#Transform><code>protocmp.Transform()</code></a> オプションを使用できます。<code>cmp</code> パッケージは任意のデータ構造を比較でき、<a href=https://pkg.go.dev/github.com/google/go-cmp/cmp#Diff><code>cmp.Diff</code></a> は値間の差異の人間が読めるレポートを生成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>diff</span> <span style=color:#ce5c00;font-weight:700>:=</span> <span style=color:#000>cmp</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Diff</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>a</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>b</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>protocmp</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Transform</span><span style=color:#000;font-weight:700>());</span> <span style=color:#000>diff</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#4e9a06>&#34;&#34;</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>t</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Errorf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;予期しない差異があります:\n%v&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>diff</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=ハイラムの法則>ハイラムの法則</h2><h3 id=hyrums-law>ハイラムの法則とは何か、そしてなぜこのFAQにあるのか？</h3><p><a href=https://www.hyrumslaw.com/>ハイラムの法則</a> は次のように述べています：</p><blockquote><p>APIの利用者が十分にいる場合、契約で約束したことは何であれ、システムのすべての観測可能な振る舞いは誰かに依存されることになります。</p></blockquote><p>GoプロトコルバッファAPIの最新バージョンの設計目標は、将来安定して保証できない観測可能な振る舞いを提供することを可能な限り避けることです。私たちの哲学は、約束をしない領域での意図的な不安定性が、安定性の幻想を与えるよりも、将来においてプロジェクトがその誤った前提に長く依存していた場合に、より良いと考えています。</p><h3 id=unstable-errors>エラーメッセージのテキストがなぜ変わり続けるのですか？</h3><p>エラーメッセージのテキストに依存するテストは壊れやすく、そのテキストが変更されると頻繁に壊れます。エラーテキストの安全でない使用を desu 、このモジュールが生成するエラーのテキストは意図的に不安定です。</p><p><a href=https://pkg.go.dev/mod/google.golang.org/protobuf><code>protobuf</code></a> モジュールによって生成されたエラーを識別する必要がある場合、すべてのエラーが <a href="https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Error"><code>proto.Error</code></a> に一致することを保証します。</p><h3 id=unstable-json><a href=https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson><code>protojson</code></a> の出力がなぜ変わり続けるのですか？</h3><p>Goのプロトコルバッファの<a href=/programming-guides/proto3#json>JSON形式</a>の実装の長期的な安定性については何も約束しません。仕様は有効なJSONを指定していますが、マーシャラーが特定のメッセージを<em>正確に</em>どのようにフォーマットすべきかについての<em>標準的な</em>フォーマットの仕様は提供していません。出力が安定しているという幻想を与えるのを避けるために、わずかな違いを意図的に導入して、バイト単位の比較が失敗する可能性が高くなるようにしています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>### [`prototext`](https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext) の出力がなぜ変わり続けるのか {#unstable-text}
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>Goのテキスト形式の実装の長期的な安定性については何も約束していません</span><span style=color:#a40000>。</span><span style=color:#000>protobufのテキスト形式には公式の仕様がなく</span><span style=color:#a40000>、将来的に</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>prototext</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#a40000>パッケージの出力を改善できるようにしたいと考えています。パッケージの出力の安定性を保証しないため、ユーザーがそれに依存することを避けるために意図的に不安定性を導入しています。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>出力の安定性を確保するために、</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>prototext</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#a40000>の出力を</span><span style=color:#000;font-weight:700>[</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>txtpbfmt</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>](</span><span style=color:#000>https</span><span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#000>github</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>com</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>protocolbuffers</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>txtpbfmt</span><span style=color:#000;font-weight:700>)</span><span style=color:#a40000>プログラムを通すことをお勧めします。このフォーマッタは、</span><span style=color:#000>Goで直接呼び出すことができます</span><span style=color:#a40000>。</span><span style=color:#000;font-weight:700>[</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>parser</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>Format</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000;font-weight:700>](</span><span style=color:#000>https</span><span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#000>pkg</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>go</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>dev</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>github</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>com</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>protocolbuffers</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>txtpbfmt</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>parser</span><span style=color:#ce5c00;font-weight:700>?</span><span style=color:#000>tab</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>doc</span><span style=color:#8f5902;font-style:italic>#Format)を使用してください。
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>## その他
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>### プロトコルバッファメッセージをハッシュキーとして使用する方法は？ {#hash}
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>プロトコルバッファメッセージのマーシャリングされた出力が時間の経過とともに安定であることを保証する正準シリアライゼーションが必要です。残念ながら、正準シリアライゼーションの仕様は現時点では存在しません。独自の方法を作成するか、それを必要としない方法を見つける必要があります。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>### Goプロトコルバッファ実装に新しい機能を追加できますか？ {#new-feature}
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>おそらくです。提案は常に歓迎していますが、新しい機能を追加する際には非常に慎重です。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>Goのプロトコルバッファの実装は</span><span style=color:#a40000>、他の言語の実装と一貫性を保つことを目指しています。そのため、</span><span style=color:#000>Goに特化しすぎた機能は避ける傾向があります</span><span style=color:#a40000>。</span><span style=color:#000>Go固有の機能は</span><span style=color:#a40000>、プロトコルバッファが言語中立のデータ交換形式であるという目標を妨げます。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#a40000>あなたのアイデアが</span><span style=color:#000>Goの実装に特化していない限り</span><span style=color:#a40000>、</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>protobufディスカッショングループ</span><span style=color:#000;font-weight:700>](</span><span style=color:#000>http</span><span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#000>groups</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>google</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>com</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#204a87;font-weight:700>group</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>protobuf</span><span style=color:#000;font-weight:700>)</span><span style=color:#a40000>に参加してそこで提案してください。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>Goの実装に関するアイデアがある場合は</span><span style=color:#a40000>、当社のイシュートラッカーにイシューを報告してください：</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000;font-weight:700>[</span><span style=color:#000>https</span><span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#000>github</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>com</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>golang</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>protobuf</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>issues</span><span style=color:#000;font-weight:700>](</span><span style=color:#000>https</span><span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>//</span><span style=color:#000>github</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>com</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>golang</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>protobuf</span><span style=color:#ce5c00;font-weight:700>/</span><span style=color:#000>issues</span><span style=color:#000;font-weight:700>)</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>### `Marshal` または `Unmarshal` にカスタマイズオプションを追加できますか？ {#new-marshal-option}
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#a40000>他の実装（例：</span><span style=color:#000>C</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#a40000>、</span><span style=color:#000>Java</span><span style=color:#a40000>）にそのオプションが存在する場合のみです。プロトコルバッファ（バイナリ、</span><span style=color:#000>JSON</span><span style=color:#a40000>、およびテキスト）のエンコーディングは、実装間で一貫している必要があります。そのため、ある言語で書かれたプログラムが他の言語で書かれたメッセージを読むことができます。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#000>Go</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>の実装には、少なくとも他のサポートされている実装の中で同等のオプションが存在する場合を除き、</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>Marshal</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>関数によって出力されるデータに影響を与えるオプションを追加しませんし、</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#000>Unmarshal</span><span style=color:#ce5c00;font-weight:700>`</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#a40000>関数によって読まれるデータに影響を与えるオプションを追加しません。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#8f5902;font-style:italic>### `protoc-gen-go` によって生成されたコードをカスタマイズできますか？ {#custom-code}
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span><span style=color:#a40000>一般的には、いいえ。プロトコルバッファは言語に依存しないデータ交換形式であり、実装固有のカスタマイズはその意図に反します。</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></main><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2024 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>プライバシーポリシー</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/js/main.min.ba08a6b7f24e657f0a1b9b55be3a3162585168cd862ace0957f5b44e6cb6dc61.js integrity="sha256-ugimt/JOZX8KG5tVvjoxYlhRaM2GKs4JV/W0Tmy23GE=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>