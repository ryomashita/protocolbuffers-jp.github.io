<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=ja class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.121.2"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Protocol Buffers Documentation</title>
<meta name=description content="このドキュメントでは、プロトコルバッファのワイヤーフォーマットについて説明します。これは、メッセージがワイヤー上で送信される方法やディスク上でどれだけのスペースを消費するかの詳細を定義しています。アプリケーションでプロトコルバッファを使用する際には、これを理解する必要はないかもしれませんが、最適化を行う際には有用な情報です。
すでに概念を理解しているが、参照資料が必要な場合は、簡略化されたリファレンスカードセクションにスキップしてください。
Protoscopeは、低レベルのワイヤーフォーマットのスニペットを記述するための非常にシンプルな言語であり、さまざまなメッセージのエンコーディングの視覚的な参照を提供するために使用されます。 Protoscopeの構文は、それぞれが特定のバイトシーケンスにエンコードされる一連のトークンで構成されています。
たとえば、バッククォートは`70726f746f6275660a`のような生の16進数リテラルを示します。これは、リテラル内の16進数で示される正確なバイトにエンコードされます。引用符はUTF-8文字列を示し、&amp;quot;Hello, Protobuf!&amp;quot;のようなものです。このリテラルは`48656c6c6f2c2050726f746f62756621`と同義です（これはASCIIバイトで構成されていることに注意してください）。ワイヤーフォーマットの側面について議論する際に、Protoscope言語のさらなる紹介を行います。
Protoscopeツールは、エンコードされたプロトコルバッファをテキストとしてダンプすることもできます。例については、https://github.com/protocolbuffers/protoscope/tree/main/testdata を参照してください。
単純なメッセージ 次の非常に単純なメッセージ定義があるとします：
message Test1 { optional int32 a = 1; } アプリケーションで、Test1メッセージを作成し、aを150に設定します。その後、メッセージを出力ストリームにシリアライズします。エンコードされたメッセージを調べることができた場合、3つのバイトが表示されます：
08 96 01 これまでのところ、小さくて数値的ですが、これは何を意味するのでしょうか？ Protoscopeツールを使用してこれらのバイトをダンプすると、1: 150のようなものが表示されます。これがメッセージの内容であることをどのように知るのでしょうか？
Base 128 Varints 可変幅整数、またはvarintsはワイヤーフォーマットの中心にあります。これにより、1から10バイトの間で符号なし64ビット整数をエンコードでき、小さな値はより少ないバイトを使用します。
varint内の各バイトには、その後に続くバイトがvarintの一部であるかどうかを示す継続ビットがあります。これはバイトの最上位ビット（MSB）です（時々符号ビットとも呼ばれます）。下位7ビットはペイロードであり、結果の整数は、構成バイトの7ビットのペイロードを連結して構築されます。
例えば、ここに数字1があります。 `01`とエンコードされています&amp;ndash;これは1バイトなので、MSBは設定されていません：
0000 0001 ^ msb そして、ここに150があります。 `9601`とエンコードされています&amp;ndash;これはもう少し複雑です：
10010110 00000001 ^ msb ^ msb これが150であることをどのように理解しますか？まず、各バイトからMSBを削除します。これは単に数値の終わりに達したかどうかを示すために存在しているだけです（最初のバイトに設定されていることがわかります。varintに複数のバイトがあるため）。これらの7ビットのペイロードはリトルエンディアン順になっています。ビッグエンディアン順に変換し、連結して符号なし64ビット整数として解釈します：
10010110 00000001 // Original inputs. 0010110 0000001 // Drop continuation bits. 0000001 0010110 // Convert to big-endian. 00000010010110 // Concatenate. 128 + 16 + 4 + 2 = 150 // Interpret as an unsigned 64-bit integer."><meta property="og:title" content><meta property="og:description" content="このドキュメントでは、プロトコルバッファのワイヤーフォーマットについて説明します。これは、メッセージがワイヤー上で送信される方法やディスク上でどれだけのスペースを消費するかの詳細を定義しています。アプリケーションでプロトコルバッファを使用する際には、これを理解する必要はないかもしれませんが、最適化を行う際には有用な情報です。
すでに概念を理解しているが、参照資料が必要な場合は、簡略化されたリファレンスカードセクションにスキップしてください。
Protoscopeは、低レベルのワイヤーフォーマットのスニペットを記述するための非常にシンプルな言語であり、さまざまなメッセージのエンコーディングの視覚的な参照を提供するために使用されます。 Protoscopeの構文は、それぞれが特定のバイトシーケンスにエンコードされる一連のトークンで構成されています。
たとえば、バッククォートは`70726f746f6275660a`のような生の16進数リテラルを示します。これは、リテラル内の16進数で示される正確なバイトにエンコードされます。引用符はUTF-8文字列を示し、&#34;Hello, Protobuf!&#34;のようなものです。このリテラルは`48656c6c6f2c2050726f746f62756621`と同義です（これはASCIIバイトで構成されていることに注意してください）。ワイヤーフォーマットの側面について議論する際に、Protoscope言語のさらなる紹介を行います。
Protoscopeツールは、エンコードされたプロトコルバッファをテキストとしてダンプすることもできます。例については、https://github.com/protocolbuffers/protoscope/tree/main/testdata を参照してください。
単純なメッセージ 次の非常に単純なメッセージ定義があるとします：
message Test1 { optional int32 a = 1; } アプリケーションで、Test1メッセージを作成し、aを150に設定します。その後、メッセージを出力ストリームにシリアライズします。エンコードされたメッセージを調べることができた場合、3つのバイトが表示されます：
08 96 01 これまでのところ、小さくて数値的ですが、これは何を意味するのでしょうか？ Protoscopeツールを使用してこれらのバイトをダンプすると、1: 150のようなものが表示されます。これがメッセージの内容であることをどのように知るのでしょうか？
Base 128 Varints 可変幅整数、またはvarintsはワイヤーフォーマットの中心にあります。これにより、1から10バイトの間で符号なし64ビット整数をエンコードでき、小さな値はより少ないバイトを使用します。
varint内の各バイトには、その後に続くバイトがvarintの一部であるかどうかを示す継続ビットがあります。これはバイトの最上位ビット（MSB）です（時々符号ビットとも呼ばれます）。下位7ビットはペイロードであり、結果の整数は、構成バイトの7ビットのペイロードを連結して構築されます。
例えば、ここに数字1があります。 `01`とエンコードされています&ndash;これは1バイトなので、MSBは設定されていません：
0000 0001 ^ msb そして、ここに150があります。 `9601`とエンコードされています&ndash;これはもう少し複雑です：
10010110 00000001 ^ msb ^ msb これが150であることをどのように理解しますか？まず、各バイトからMSBを削除します。これは単に数値の終わりに達したかどうかを示すために存在しているだけです（最初のバイトに設定されていることがわかります。varintに複数のバイトがあるため）。これらの7ビットのペイロードはリトルエンディアン順になっています。ビッグエンディアン順に変換し、連結して符号なし64ビット整数として解釈します：
10010110 00000001 // Original inputs. 0010110 0000001 // Drop continuation bits. 0000001 0010110 // Convert to big-endian. 00000010010110 // Concatenate. 128 + 16 + 4 + 2 = 150 // Interpret as an unsigned 64-bit integer."><meta property="og:type" content="article"><meta property="og:url" content="https://protobuf.dev/ja/programming-guides/encoding/"><meta property="article:section" content="programming-guides"><meta itemprop=name content><meta itemprop=description content="このドキュメントでは、プロトコルバッファのワイヤーフォーマットについて説明します。これは、メッセージがワイヤー上で送信される方法やディスク上でどれだけのスペースを消費するかの詳細を定義しています。アプリケーションでプロトコルバッファを使用する際には、これを理解する必要はないかもしれませんが、最適化を行う際には有用な情報です。
すでに概念を理解しているが、参照資料が必要な場合は、簡略化されたリファレンスカードセクションにスキップしてください。
Protoscopeは、低レベルのワイヤーフォーマットのスニペットを記述するための非常にシンプルな言語であり、さまざまなメッセージのエンコーディングの視覚的な参照を提供するために使用されます。 Protoscopeの構文は、それぞれが特定のバイトシーケンスにエンコードされる一連のトークンで構成されています。
たとえば、バッククォートは`70726f746f6275660a`のような生の16進数リテラルを示します。これは、リテラル内の16進数で示される正確なバイトにエンコードされます。引用符はUTF-8文字列を示し、&#34;Hello, Protobuf!&#34;のようなものです。このリテラルは`48656c6c6f2c2050726f746f62756621`と同義です（これはASCIIバイトで構成されていることに注意してください）。ワイヤーフォーマットの側面について議論する際に、Protoscope言語のさらなる紹介を行います。
Protoscopeツールは、エンコードされたプロトコルバッファをテキストとしてダンプすることもできます。例については、https://github.com/protocolbuffers/protoscope/tree/main/testdata を参照してください。
単純なメッセージ 次の非常に単純なメッセージ定義があるとします：
message Test1 { optional int32 a = 1; } アプリケーションで、Test1メッセージを作成し、aを150に設定します。その後、メッセージを出力ストリームにシリアライズします。エンコードされたメッセージを調べることができた場合、3つのバイトが表示されます：
08 96 01 これまでのところ、小さくて数値的ですが、これは何を意味するのでしょうか？ Protoscopeツールを使用してこれらのバイトをダンプすると、1: 150のようなものが表示されます。これがメッセージの内容であることをどのように知るのでしょうか？
Base 128 Varints 可変幅整数、またはvarintsはワイヤーフォーマットの中心にあります。これにより、1から10バイトの間で符号なし64ビット整数をエンコードでき、小さな値はより少ないバイトを使用します。
varint内の各バイトには、その後に続くバイトがvarintの一部であるかどうかを示す継続ビットがあります。これはバイトの最上位ビット（MSB）です（時々符号ビットとも呼ばれます）。下位7ビットはペイロードであり、結果の整数は、構成バイトの7ビットのペイロードを連結して構築されます。
例えば、ここに数字1があります。 `01`とエンコードされています&ndash;これは1バイトなので、MSBは設定されていません：
0000 0001 ^ msb そして、ここに150があります。 `9601`とエンコードされています&ndash;これはもう少し複雑です：
10010110 00000001 ^ msb ^ msb これが150であることをどのように理解しますか？まず、各バイトからMSBを削除します。これは単に数値の終わりに達したかどうかを示すために存在しているだけです（最初のバイトに設定されていることがわかります。varintに複数のバイトがあるため）。これらの7ビットのペイロードはリトルエンディアン順になっています。ビッグエンディアン順に変換し、連結して符号なし64ビット整数として解釈します：
10010110 00000001 // Original inputs. 0010110 0000001 // Drop continuation bits. 0000001 0010110 // Convert to big-endian. 00000010010110 // Concatenate. 128 + 16 + 4 + 2 = 150 // Interpret as an unsigned 64-bit integer."><meta itemprop=wordCount content="901"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="このドキュメントでは、プロトコルバッファのワイヤーフォーマットについて説明します。これは、メッセージがワイヤー上で送信される方法やディスク上でどれだけのスペースを消費するかの詳細を定義しています。アプリケーションでプロトコルバッファを使用する際には、これを理解する必要はないかもしれませんが、最適化を行う際には有用な情報です。
すでに概念を理解しているが、参照資料が必要な場合は、簡略化されたリファレンスカードセクションにスキップしてください。
Protoscopeは、低レベルのワイヤーフォーマットのスニペットを記述するための非常にシンプルな言語であり、さまざまなメッセージのエンコーディングの視覚的な参照を提供するために使用されます。 Protoscopeの構文は、それぞれが特定のバイトシーケンスにエンコードされる一連のトークンで構成されています。
たとえば、バッククォートは`70726f746f6275660a`のような生の16進数リテラルを示します。これは、リテラル内の16進数で示される正確なバイトにエンコードされます。引用符はUTF-8文字列を示し、&#34;Hello, Protobuf!&#34;のようなものです。このリテラルは`48656c6c6f2c2050726f746f62756621`と同義です（これはASCIIバイトで構成されていることに注意してください）。ワイヤーフォーマットの側面について議論する際に、Protoscope言語のさらなる紹介を行います。
Protoscopeツールは、エンコードされたプロトコルバッファをテキストとしてダンプすることもできます。例については、https://github.com/protocolbuffers/protoscope/tree/main/testdata を参照してください。
単純なメッセージ 次の非常に単純なメッセージ定義があるとします：
message Test1 { optional int32 a = 1; } アプリケーションで、Test1メッセージを作成し、aを150に設定します。その後、メッセージを出力ストリームにシリアライズします。エンコードされたメッセージを調べることができた場合、3つのバイトが表示されます：
08 96 01 これまでのところ、小さくて数値的ですが、これは何を意味するのでしょうか？ Protoscopeツールを使用してこれらのバイトをダンプすると、1: 150のようなものが表示されます。これがメッセージの内容であることをどのように知るのでしょうか？
Base 128 Varints 可変幅整数、またはvarintsはワイヤーフォーマットの中心にあります。これにより、1から10バイトの間で符号なし64ビット整数をエンコードでき、小さな値はより少ないバイトを使用します。
varint内の各バイトには、その後に続くバイトがvarintの一部であるかどうかを示す継続ビットがあります。これはバイトの最上位ビット（MSB）です（時々符号ビットとも呼ばれます）。下位7ビットはペイロードであり、結果の整数は、構成バイトの7ビットのペイロードを連結して構築されます。
例えば、ここに数字1があります。 `01`とエンコードされています&ndash;これは1バイトなので、MSBは設定されていません：
0000 0001 ^ msb そして、ここに150があります。 `9601`とエンコードされています&ndash;これはもう少し複雑です：
10010110 00000001 ^ msb ^ msb これが150であることをどのように理解しますか？まず、各バイトからMSBを削除します。これは単に数値の終わりに達したかどうかを示すために存在しているだけです（最初のバイトに設定されていることがわかります。varintに複数のバイトがあるため）。これらの7ビットのペイロードはリトルエンディアン順になっています。ビッグエンディアン順に変換し、連結して符号なし64ビット整数として解釈します：
10010110 00000001 // Original inputs. 0010110 0000001 // Drop continuation bits. 0000001 0010110 // Convert to big-endian. 00000010010110 // Concatenate. 128 + 16 + 4 + 2 = 150 // Interpret as an unsigned 64-bit integer."><link rel=preload href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css as=style><link href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/ja/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Protocol Buffers Documentation</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item dropdown mr-4 d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/programming-guides/encoding/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder=サイトを検索... aria-label=サイトを検索... autocomplete=off></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><p>このドキュメントでは、プロトコルバッファの<em>ワイヤーフォーマット</em>について説明します。これは、メッセージがワイヤー上で送信される方法やディスク上でどれだけのスペースを消費するかの詳細を定義しています。アプリケーションでプロトコルバッファを使用する際には、これを理解する必要はないかもしれませんが、最適化を行う際には有用な情報です。</p><p>すでに概念を理解しているが、参照資料が必要な場合は、<a href=#cheat-sheet>簡略化されたリファレンスカード</a>セクションにスキップしてください。</p><p><a href=https://github.com/protocolbuffers/protoscope>Protoscope</a>は、低レベルのワイヤーフォーマットのスニペットを記述するための非常にシンプルな言語であり、さまざまなメッセージのエンコーディングの視覚的な参照を提供するために使用されます。 Protoscopeの構文は、それぞれが特定のバイトシーケンスにエンコードされる一連の<em>トークン</em>で構成されています。</p><p>たとえば、バッククォートは<code>`70726f746f6275660a`</code>のような生の16進数リテラルを示します。これは、リテラル内の16進数で示される正確なバイトにエンコードされます。引用符はUTF-8文字列を示し、<code>"Hello, Protobuf!"</code>のようなものです。このリテラルは<code>`48656c6c6f2c2050726f746f62756621`</code>と同義です（これはASCIIバイトで構成されていることに注意してください）。ワイヤーフォーマットの側面について議論する際に、Protoscope言語のさらなる紹介を行います。</p><p>Protoscopeツールは、エンコードされたプロトコルバッファをテキストとしてダンプすることもできます。例については、https://github.com/protocolbuffers/protoscope/tree/main/testdata を参照してください。</p><h2 id=simple>単純なメッセージ</h2><p>次の非常に単純なメッセージ定義があるとします：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test1</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>optional</span> <span style=color:#204a87;font-weight:700>int32</span> <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>アプリケーションで、<code>Test1</code>メッセージを作成し、<code>a</code>を150に設定します。その後、メッセージを出力ストリームにシリアライズします。エンコードされたメッセージを調べることができた場合、3つのバイトが表示されます：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>08</span> <span style=color:#0000cf;font-weight:700>96</span> <span style=color:#0000cf;font-weight:700>01</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>これまでのところ、小さくて数値的ですが、これは何を意味するのでしょうか？ Protoscopeツールを使用してこれらのバイトをダンプすると、<code>1: 150</code>のようなものが表示されます。これがメッセージの内容であることをどのように知るのでしょうか？</p><h2 id=varints>Base 128 Varints</h2><p>可変幅整数、または<em>varints</em>はワイヤーフォーマットの中心にあります。これにより、1から10バイトの間で符号なし64ビット整数をエンコードでき、小さな値はより少ないバイトを使用します。</p><p>varint内の各バイトには、その後に続くバイトがvarintの一部であるかどうかを示す<em>継続ビット</em>があります。これはバイトの<em>最上位ビット</em>（MSB）です（時々<em>符号ビット</em>とも呼ばれます）。下位7ビットはペイロードであり、結果の整数は、構成バイトの7ビットのペイロードを連結して構築されます。</p><p>例えば、ここに数字1があります。 <code>`01`</code>とエンコードされています&ndash;これは1バイトなので、MSBは設定されていません：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>0000</span> <span style=color:#0000cf;font-weight:700>0001</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>^</span> <span style=color:#000>msb</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>そして、ここに150があります。 <code>`9601`</code>とエンコードされています&ndash;これはもう少し複雑です：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>10010110</span> <span style=color:#0000cf;font-weight:700>00000001</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>^</span> <span style=color:#000>msb</span>    <span style=color:#a40000>^</span> <span style=color:#000>msb</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>これが150であることをどのように理解しますか？まず、各バイトからMSBを削除します。これは単に数値の終わりに達したかどうかを示すために存在しているだけです（最初のバイトに設定されていることがわかります。varintに複数のバイトがあるため）。これらの7ビットのペイロードはリトルエンディアン順になっています。ビッグエンディアン順に変換し、連結して符号なし64ビット整数として解釈します：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>10010110</span> <span style=color:#0000cf;font-weight:700>00000001</span>        <span style=color:#8f5902;font-style:italic>// Original inputs.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span> <span style=color:#0000cf;font-weight:700>0010110</span>  <span style=color:#0000cf;font-weight:700>0000001</span>        <span style=color:#8f5902;font-style:italic>// Drop continuation bits.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span> <span style=color:#0000cf;font-weight:700>0000001</span>  <span style=color:#0000cf;font-weight:700>0010110</span>        <span style=color:#8f5902;font-style:italic>// Convert to big-endian.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>   <span style=color:#0000cf;font-weight:700>00000010010110</span>        <span style=color:#8f5902;font-style:italic>// Concatenate.
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span> <span style=color:#0000cf;font-weight:700>128</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>16</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>150</span>  <span style=color:#8f5902;font-style:italic>// Interpret as an unsigned 64-bit integer.
</span></span></span></code></pre></div><p>プロトコルバッファにとってvarintsが非常に重要であるため、プロトスコープ構文では、これらを単純な整数として参照します。 <code>150</code>は <code>`9601`</code>と同じです。</p><h2 id=structure>メッセージ構造</h2><p>プロトコルバッファメッセージはキーと値のペアのシリーズです。メッセージのバイナリバージョンでは、各フィールドの番号がキーとして使用されます&ndash;各フィールドの名前と宣言されたタイプは、デコーディングエンドでのみ、メッセージタイプの定義（つまり<code>.proto</code>ファイル）を参照することで決定できます。プロトスコープはこの情報にアクセスできないため、フィールド番号のみを提供できます。</p><p>メッセージがエンコードされると、各キーと値のペアは、フィールド番号、ワイヤータイプ、およびペイロードから構成される<em>レコード</em>に変換されます。ワイヤータイプは、その後に続くペイロードの大きさをパーサーに伝えます。これにより、古いパーサーが理解できない新しいフィールドをスキップできます。このタイプのスキームは、<a href=https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value>Tag-Length-Value</a>またはTLVと呼ばれることがあります。</p><p>存在するワイヤータイプは6つあります：<code>VARINT</code>、<code>I64</code>、<code>LEN</code>、<code>SGROUP</code>、<code>EGROUP</code>、<code>I32</code></p><table><thead><tr><th>ID</th><th>名前</th><th>用途</th></tr></thead><tbody><tr><td>0</td><td>VARINT</td><td>int32、int64、uint32、uint64、sint32、sint64、bool、enum</td></tr><tr><td>1</td><td>I64</td><td>fixed64、sfixed64、double</td></tr><tr><td>2</td><td>LEN</td><td>string、bytes、埋め込まれたメッセージ、繰り返しフィールドのパック</td></tr><tr><td>3</td><td>SGROUP</td><td>グループ開始（非推奨）</td></tr><tr><td>4</td><td>EGROUP</td><td>グループ終了（非推奨）</td></tr><tr><td>5</td><td>I32</td><td>fixed32、sfixed32、float</td></tr></tbody></table><p>レコードの「タグ」は、フィールド番号とワイヤータイプから構成される varint としてエンコードされます。具体的には、式 <code>(field_number &lt;&lt; 3) | wire_type</code> によって形成されます。言い換えると、フィールドを表す varint をデコードした後、下位 3 ビットがワイヤータイプを示し、整数の残りの部分がフィールド番号を示します。</p><p>さて、簡単な例をもう一度見てみましょう。今度は、ストリーム内の最初の数値が常に varint キーであることを知っています。ここでは、<code>`08`</code> または（MSB を削除して）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>000</span> <span style=color:#0000cf;font-weight:700>1000</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>最後の 3 ビットを取得してワイヤータイプ（0）を取得し、その後 3 ビット右にシフトしてフィールド番号（1）を取得します。Protoscope では、タグを整数に続いてコロンとワイヤータイプで表現します。したがって、上記のバイトを <code>1:VARINT</code> と書くことができます。</p><p>ワイヤータイプが 0 または <code>VARINT</code> であるため、ペイロードを取得するために varint をデコードする必要があることがわかります。上記で見たように、バイト <code>`9601`</code> は varint デコードして 150 になり、私たちのレコードを取得します。Protoscope では、<code>1:VARINT 150</code> として書くことができます。</p><p>Protoscope は、<code>:</code> の後に空白がある場合、タグの型を推測できます。次のトークンを先読みして、意図した内容を推測します（詳細なルールは <a href=https://github.com/protocolbuffers/protoscope/blob/main/language.txt>Protoscope&rsquo;s language.txt</a> に詳細に記載されています）。たとえば、<code>1: 150</code> では、未型指定のタグの直後に varint があるため、Protoscope はその型を <code>VARINT</code> と推測します。<code>2: {}</code> を書いた場合、<code>{</code> を見て <code>LEN</code> と推測し、<code>3: 5i32</code> を書いた場合は <code>I32</code> と推測します。</p><h2 id=int-types>さらなる整数型</h2><h3 id=bools-and-enums>Bools と Enums</h3><p>Boolsとenumsは両方とも<code>int32</code>としてエンコードされます。特にBoolsは、常に<code>`00`</code>または<code>`01`</code>としてエンコードされます。Protoscopeでは、<code>false</code>と<code>true</code>はこれらのバイト文字列のエイリアスです。</p><h3 id=signed-ints>符号付き整数</h3><p>前のセクションで見たように、ワイヤータイプ0に関連付けられたすべてのプロトコルバッファタイプはvarintsとしてエンコードされます。ただし、varintsは符号なしですので、<code>sint32</code>および<code>sint64</code>と<code>int32</code>または<code>int64</code>のような異なる符号付きタイプは、負の整数を異なる方法でエンコードします。</p><p><code>intN</code>タイプは、負の数を2の補数としてエンコードします。これは、符号なしの64ビット整数として、最上位ビットが設定されていることを意味します。その結果、これは<em>すべての10バイト</em>を使用する必要があることを意味します。たとえば、<code>-2</code>は、protoscopeによって次のように変換されます</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>11111110</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>00000001</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>これは、2の<em>2の補数</em>であり、符号なし算術で定義される<code>~0 - 2 + 1</code>であり、<code>~0</code>がすべて1の64ビット整数であることを意味します。これがなぜこれほど多くの1を生成するのかを理解するのは有益な練習です。</p><p><code>sintN</code>は、負の整数をエンコードするために2の補数の代わりに「ZigZag」エンコーディングを使用します。正の整数<code>p</code>は<code>2 * p</code>（偶数）としてエンコードされ、負の整数<code>n</code>は<code>2 * |n| - 1</code>（奇数）としてエンコードされます。このエンコーディングは、正の数と負の数の間を「ジグザグ」します。たとえば：</p><table><thead><tr><th>符号つき元の数</th><th>エンコードされた値</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>-2</td><td>3</td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr><tr><td>0x7fffffff</td><td>0xfffffffe</td></tr><tr><td>-0x80000000</td><td>0xffffffff</td></tr></tbody></table><p>つまり、各値<code>n</code>は次のようにエンコードされます</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)
</span></span></code></pre></div><p><code>sint32</code>の場合、または</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>(n &lt;&lt; 1) ^ (n &gt;&gt; 63)
</span></span></code></pre></div><p>64ビットバージョンの場合。</p><p><code>sint32</code>または<code>sint64</code>が解析されると、その値は元の符号付きバージョンにデコードされます。</p><p>protoscopeでは、整数に<code>z</code>を付けるとZigZagとしてエンコードされます。たとえば、<code>-500z</code>はvarint <code>999</code>と同じです。</p><h3 id=non-varints>非可変長数値</h3><p>非可変長数値型はシンプルです。<code>double</code> と <code>fixed64</code> はワイヤータイプ <code>I64</code> を持ち、これはパーサーに固定の8バイトのデータを期待することを伝えます。<code>double</code> レコードは <code>5: 25.4</code> と書くことで指定できますし、<code>fixed64</code> レコードは <code>6: 200i64</code> と書くことで指定できます。どちらの場合も、明示的なワイヤータイプを省略すると <code>I64</code> ワイヤータイプが適用されます。</p><p>同様に、<code>float</code> と <code>fixed32</code> はワイヤータイプ <code>I32</code> を持ち、4バイトのデータを期待することを示します。これらの構文は <code>i32</code> 接頭辞を追加することで表されます。<code>25.4i32</code> は4バイトを生成し、<code>200i32</code> も同様です。タグのタイプは <code>I32</code> と推論されます。</p><h2 id=length-types>長さ指定レコード</h2><p><em>長さプレフィックス</em> はワイヤーフォーマットにおけるもう一つの重要な概念です。<code>LEN</code> ワイヤータイプは、タグの直後に即座に指定される可変長の長さを持ち、通常のペイロードが続きます。</p><p>次のメッセージスキーマを考えてみましょう：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test2</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>optional</span> <span style=color:#204a87;font-weight:700>string</span> <span style=color:#000>b</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>フィールド <code>b</code> のレコードは文字列であり、文字列は <code>LEN</code> でエンコードされます。もし <code>b</code> を <code>"testing"</code> に設定した場合、ASCII文字列 <code>"testing"</code> を含むフィールド番号2の <code>LEN</code> レコードとしてエンコードされます。結果は <code>`120774657374696e67`</code> です。バイトを分割すると、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>12</span> <span style=color:#0000cf;font-weight:700>07</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>74</span> <span style=color:#0000cf;font-weight:700>65</span> <span style=color:#0000cf;font-weight:700>73</span> <span style=color:#0000cf;font-weight:700>74</span> <span style=color:#0000cf;font-weight:700>69</span> <span style=color:#0000cf;font-weight:700>6</span><span style=color:#000>e</span> <span style=color:#0000cf;font-weight:700>67</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>タグである <code>`12`</code> は <code>00010 010</code> または <code>2:LEN</code> を表し、その後に続くバイトは int32 の可変長 <code>7</code> であり、次の7バイトは <code>"testing"</code> の UTF-8 エンコーディングです。int32 の可変長は、文字列の最大長さが2GBであることを意味します。</p><p>Protoscopeでは、これは <code>2:LEN 7 "testing"</code> と書かれます。しかし、文字列の長さを繰り返すのは不便かもしれません（Protoscopeテキストでは既に引用符で囲まれています）。Protoscopeコンテンツを中括弧で囲むと、それに対して長さプレフィックスが生成されます：<code>{"testing"}</code> は <code>7 "testing"</code> の省略形です。<code>{}</code> は常にフィールドによって <code>LEN</code> レコードと推論されるため、このレコードは単純に <code>2: {"testing"}</code> と書くことができます。</p><p><code>bytes</code> フィールドも同様にエンコードされます。</p><h3 id=embedded>サブメッセージ</h3><p>サブメッセージフィールドも <code>LEN</code> ワイヤータイプを使用します。以下は、元の例メッセージ <code>Test1</code> の埋め込まれたメッセージを持つメッセージ定義です：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test3</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>optional</span> <span style=color:#000>Test1</span> <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>もし <code>Test1</code> の <code>a</code> フィールド（つまり、<code>Test3</code> の <code>c.a</code> フィールド）が 150 に設定されている場合、我々は <code>1a03089601</code> を得ます。分解すると：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000>a</span> <span style=color:#0000cf;font-weight:700>03</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>08</span> <span style=color:#0000cf;font-weight:700>96</span> <span style=color:#0000cf;font-weight:700>01</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>最後の3バイト（<code>[]</code> 内）は、まさに私たちの<a href=#simple>最初の例</a>からのものです。これらのバイトは <code>LEN</code> 型のタグに続き、長さ3、まさに文字列がエンコードされる方法と同じです。</p><p>Protoscope では、サブメッセージは非常に簡潔です。<code>1a03089601</code> は <code>3: {1: 150}</code> と書くことができます。</p><h2 id=optional>Optional and Repeated Elements</h2><p>欠落している <code>optional</code> フィールドは簡単にエンコードできます：存在しない場合はレコードを省略します。これは、わずかなフィールドが設定された「巨大な」プロトはかなり疎です。</p><p><code>repeated</code> フィールドは少し複雑です。通常の（<a href=#packed>packed</a>でない）repeated フィールドは、フィールドの各要素ごとに1つのレコードを発行します。したがって、次のような場合、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test4</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>optional</span> <span style=color:#204a87;font-weight:700>string</span> <span style=color:#000>d</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>repeated</span> <span style=color:#204a87;font-weight:700>int32</span> <span style=color:#000>e</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p><code>d</code> が <code>"hello"</code> に設定され、<code>e</code> が <code>1</code>、<code>2</code>、<code>3</code> に設定された <code>Test4</code> メッセージを構築すると、これは <code>`220568656c6c6f280128022803`</code> としてエンコードされるか、Protoscope で書かれるかもしれません。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;hello&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>ただし、<code>e</code> のレコードは連続して表示する必要はなく、他のフィールドと交互に配置することができます。同じフィールドのレコード同士の順序だけが保持されます。したがって、これは次のようにエンコードされる可能性があります</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;hello&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#a40000>
</span></span></span></code></pre></div><h3 id=oneofs>Oneofs</h3><p><a href=/programming-guides/proto2#oneof><code>Oneof</code> フィールド</a> は、<code>oneof</code> 内のフィールドであるかのようにエンコードされます。<code>oneof</code> に適用されるルールは、ワイヤ上でどのように表現されているかには独立して適用されます。</p><h3 id=last-one-wins>Last One Wins</h3><p>通常、エンコードされたメッセージには非 <code>repeated</code> フィールドの複数のインスタンスが含まれることはありません。ただし、パーサーはそれが含まれる場合に対処することが期待されています。数値型と文字列の場合、同じフィールドが複数回現れる場合、パーサーは見た<em>最後の</em>値を受け入れます。埋め込みメッセージフィールドの場合、パーサーは同じフィールドの複数のインスタンスをマージします。これらのルールの効果は、2つのエンコードされたメッセージの連結を解析すると、2つのメッセージを別々に解析して生成されたオブジェクトをマージしたかのような結果が得られることです。つまり、これは:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#000>MyMessage</span> <span style=color:#000>message</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000>message</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ParseFromString</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>str1</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>str2</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>は、次のように等価です：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#000>MyMessage</span> <span style=color:#000>message</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>message2</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000>message</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ParseFromString</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>str1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>message2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ParseFromString</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>str2</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>message</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>MergeFrom</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>message2</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>このプロパティは時折便利であり、タイプがわからなくても2つのメッセージを（連結して）マージできるようにします。</p><h3 id=packed>パックされた繰り返しフィールド</h3><p>v2.1.0から、プリミティブ型の <code>repeated</code> フィールド（<code>string</code> または <code>bytes</code> でない任意の<a href=/programming-guides/proto2#scalar>スカラー型</a>）を「パックされた」状態で宣言できます。proto2 では、これはフィールドオプション <code>[packed=true]</code> を使用して行われます。proto3 ではデフォルトです。</p><p>1つのエントリごとに1つのレコードとしてエンコードされる代わりに、それらは各要素が連結された単一の <code>LEN</code> レコードとしてエンコードされます。デコードする際は、要素が <code>LEN</code> レコードから1つずつデコードされ、ペイロードが尽きるまで続きます。次の要素の開始位置は、前の要素の長さによって決定され、それ自体はフィールドのタイプに依存します。</p><p>例えば、次のメッセージ型があるとします：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test5</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>repeated</span> <span style=color:#204a87;font-weight:700>int32</span> <span style=color:#000>f</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>6</span> <span style=color:#000;font-weight:700>[</span><span style=color:#204a87;font-weight:700>packed</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>true</span><span style=color:#000;font-weight:700>];</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>今、<code>Test5</code> を構築し、繰り返しフィールド <code>f</code> に値 3、270、86942 を提供したとします。エンコードすると、<code>`3206038e029ea705`</code> となり、Protoscope テキストでは次のようになります：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>3</span> <span style=color:#0000cf;font-weight:700>270</span> <span style=color:#0000cf;font-weight:700>86942</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>「パックされた」状態にできるのは、プリミティブ数値型の繰り返しフィールドのみです。これらは通常、<code>VARINT</code>、<code>I32</code>、または <code>I64</code> ワイヤータイプを使用するタイプです。</p><p>パックされた繰り返しフィールドに複数のキーと値のペアをエンコードする理由は通常ありませんが、パーサーは複数のキーと値のペアを受け入れる準備をしている必要があります。この場合、ペイロードは連結される必要があります。各ペアは要素の整数倍を含んでいる必要があります。次は、パーサーが受け入れる必要がある同じメッセージの有効なエンコーディングです：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>3</span> <span style=color:#0000cf;font-weight:700>270</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>86942</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>プロトコルバッファパーサーは、<code>packed</code> としてコンパイルされた繰り返しフィールドを、パックされていないかのように解析できるようにする必要があります。これにより、既存のフィールドに <code>[packed=true]</code> を追加することが、前方および後方互換性のある方法で可能になります。</p><h3 id=maps>マップ</h3><p>Mapフィールドは、特別な種類の繰り返しフィールドの省略形です。以下のような場合、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test6</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#000>map</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>string</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000>g</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>実際には次のようになります</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test6</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>g_Entry</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>    <span style=color:#204a87;font-weight:700>optional</span> <span style=color:#204a87;font-weight:700>string</span> <span style=color:#000>key</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>    <span style=color:#204a87;font-weight:700>optional</span> <span style=color:#204a87;font-weight:700>int32</span> <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>repeated</span> <span style=color:#000>g_Entry</span> <span style=color:#000>g</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>したがって、マップは、2つのフィールドを持つ<code>LEN</code>型のレコードのシーケンスとして、<code>repeated</code>メッセージフィールドとまったく同じようにエンコードされます。</p><h2 id=groups>グループ</h2><p>グループは使用されるべきでない非推奨の機能ですが、ワイヤーフォーマットには残っており、一言で触れる価値があります。</p><p>グループはサブメッセージのようなものですが、<code>LEN</code>プレフィックスではなく特別なタグで区切られています。メッセージ内の各グループにはフィールド番号があり、これらの特別なタグで使用されます。</p><p>フィールド番号<code>8</code>のグループは<code>8:SGROUP</code>タグで始まります。<code>SGROUP</code>レコードには空のペイロードがあり、これによりグループの開始が示されます。グループ内のすべてのフィールドがリストされた後、対応する<code>8:EGROUP</code>タグがその終わりを示します。<code>EGROUP</code>レコードにもペイロードがないため、<code>8:EGROUP</code>は完全なレコードです。グループのフィールド番号は一致する必要があります。<code>8:EGROUP</code>が期待される場所で<code>7:EGROUP</code>が発生した場合、メッセージは不正な形式です。</p><p>Protoscopeはグループを書くための便利な構文を提供します。次のように書く代わりに</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>:</span><span style=color:#000>SGROUP</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>1</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>3</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;foo&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>:</span><span style=color:#000>EGROUP</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>Protoscopeでは次のように書くことができます</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#a40000>!</span><span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>1</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>3</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;foo&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>これにより、適切な開始および終了グループマーカーが生成されます。<code>!{}</code>構文は、<code>8:</code>のような未入力のタグ式の直後にのみ発生できます。</p><h2 id=order>フィールドの順序</h2><p>フィールド番号は<code>.proto</code>ファイル内で任意の順序で宣言される可能性があります。選択された順序は、メッセージがシリアライズされる方法に影響を与えません。</p><p>メッセージがシリアライズされるとき、既知のフィールドまたは<a href=/programming-guides/proto2#updating>未知のフィールド</a>がどのように書き込まれるかについては保証されません。シリアル化の順序は実装の詳細であり、特定の実装の詳細は将来変更される可能性があります。したがって、プロトコルバッファパーサは、フィールドを任意の順序で解析できる必要があります。</p><h3 id=implications>影響</h3><ul><li>シリアル化されたメッセージのバイト出力が安定しているとは限りません。これは特に、他のシリアル化されたプロトコルバッファメッセージを表すトランジティブバイトフィールドを持つメッセージの場合に当てはまります。</li><li>デフォルトでは、同じプロトコルバッファメッセージインスタンスに対するシリアル化メソッドの繰り返し呼び出しは、同じバイト出力を生成しない場合があります。つまり、デフォルトのシリアル化は決定論的ではありません。<ul><li>決定論的シリアル化は、特定のバイナリに対して同じバイト出力を保証します。バイト出力は、バイナリの異なるバージョン間で変更する可能性があります。</li></ul></li><li>プロトコルバッファメッセージインスタンス<code>foo</code>に対して次のチェックが失敗する可能性があります：<ul><li><code>foo.SerializeAsString() == foo.SerializeAsString()</code></li><li><code>Hash(foo.SerializeAsString()) == Hash(foo.SerializeAsString())</code></li><li><code>CRC(foo.SerializeAsString()) == CRC(foo.SerializeAsString())</code></li><li><code>FingerPrint(foo.SerializeAsString()) == FingerPrint(foo.SerializeAsString())</code></li></ul></li><li>論理的に等価なプロトコルバッファメッセージ<code>foo</code>と<code>bar</code>が異なるバイト出力にシリアル化される可能性があるいくつかの例のシナリオは次のとおりです：<ul><li><code>bar</code>は、一部のフィールドを未知として扱う古いサーバーによってシリアル化されています。</li><li><code>bar</code>は、異なるプログラミング言語で実装されたサーバーによってシリアル化され、フィールドが異なる順序でシリアル化されています。</li><li><code>bar</code>には、決定論的でない方法でシリアル化されるフィールドがあります。</li><li><code>bar</code>には、異なる方法でシリアル化されるプロトコルバッファメッセージのシリアル化バイト出力を格納するフィールドがあります。</li><li><code>bar</code>は、実装の変更により異なる順序でフィールドをシリアル化する新しいサーバーによってシリアル化されています。</li><li><code>foo</code>と<code>bar</code>は、異なる順序で個々のメッセージの連結です。</li></ul></li></ul><h2 id=size-limit>エンコードされた Proto のサイズ制限</h2><p>Proto はシリアライズされたときに 2 GiB より小さくなければなりません。多くの Proto 実装は、この制限を超えるメッセージをシリアライズまたは解析することを拒否します。</p><h2 id=cheat-sheet>コンデンスド リファレンス カード</h2><p>以下は、ワイヤ形式の最も顕著な部分を簡単に参照できる形式で提供します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#000>message</span>    <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>tag</span> <span style=color:#000>value</span><span style=color:#000;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>tag</span>        <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>field</span> <span style=color:#ce5c00;font-weight:700>&lt;&lt;</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#204a87;font-weight:700>or</span> <span style=color:#000>wire_type</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#000>encoded</span> <span style=color:#000>as</span> <span style=color:#000>uint32</span> <span style=color:#000>varint</span>
</span></span><span style=display:flex><span><span style=color:#000>value</span>      <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>varint</span>      <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>VARINT</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#000>i32</span>         <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>I32</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#000>i64</span>         <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>I64</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#000>len</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>prefix</span>  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>LEN</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>empty</span><span style=color:#ce5c00;font-weight:700>&gt;</span>     <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>SGROUP</span> <span style=color:#204a87;font-weight:700>or</span> <span style=color:#000>EGROUP</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>varint</span>     <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>int32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>int64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>uint32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>uint64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#c00;font-weight:700>bool</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#204a87;font-weight:700>enum</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>sint32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>sint64</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#000>encoded</span> <span style=color:#000>as</span> <span style=color:#000>varints</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>sintN</span> <span style=color:#000>are</span> <span style=color:#000>ZigZag</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>encoded</span> <span style=color:#000>first</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>i32</span>        <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>sfixed32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>fixed32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#c00;font-weight:700>float</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#000>encoded</span> <span style=color:#000>as</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>byte</span> <span style=color:#000>little</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>endian</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#000>memcpy</span> <span style=color:#000>of</span> <span style=color:#000>the</span> <span style=color:#000>equivalent</span> <span style=color:#000>C</span> <span style=color:#000>types</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>u</span><span style=color:#a40000>?</span><span style=color:#000>int32_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#c00;font-weight:700>float</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#000>i64</span>        <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>sfixed64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>fixed64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>double</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#000>encoded</span> <span style=color:#000>as</span> <span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>byte</span> <span style=color:#000>little</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>endian</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#000>memcpy</span> <span style=color:#000>of</span> <span style=color:#000>the</span> <span style=color:#000>equivalent</span> <span style=color:#000>C</span> <span style=color:#000>types</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>u</span><span style=color:#a40000>?</span><span style=color:#000>int64_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>double</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>len</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>prefix</span> <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>size</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>message</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>string</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>bytes</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>packed</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>                <span style=color:#000>size</span> <span style=color:#000>encoded</span> <span style=color:#000>as</span> <span style=color:#000>int32</span> <span style=color:#000>varint</span>
</span></span><span style=display:flex><span><span style=color:#000>string</span>     <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>valid</span> <span style=color:#000>UTF</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>8</span> <span style=color:#000>string</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>e</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>g</span><span style=color:#ce5c00;font-weight:700>.</span> <span style=color:#000>ASCII</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>                <span style=color:#204a87>max</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000>GB</span> <span style=color:#000>of</span> <span style=color:#000>bytes</span>
</span></span><span style=display:flex><span><span style=color:#000>bytes</span>      <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>any</span> <span style=color:#000>sequence</span> <span style=color:#000>of</span> <span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>bit</span> <span style=color:#000>bytes</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#204a87>max</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000>GB</span> <span style=color:#000>of</span> <span style=color:#000>bytes</span>
</span></span><span style=display:flex><span><span style=color:#000>packed</span>     <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>varint</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>i32</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>i64</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>                <span style=color:#000>consecutive</span> <span style=color:#000>values</span> <span style=color:#000>of</span> <span style=color:#000>the</span> <span style=color:#000>type</span> <span style=color:#000>specified</span> <span style=color:#204a87;font-weight:700>in</span> <span style=color:#a40000>`</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>proto</span><span style=color:#a40000>`</span>
</span></span></code></pre></div><p>また、<a href=https://github.com/protocolbuffers/protoscope/blob/main/language.txt>Protoscope 言語リファレンス</a> も参照してください。</p><h3 id=cheat-sheet-key>キー</h3><dl><dt><code>message := (tag value)*</code></dt><dd>メッセージは、タグと値のペアのゼロ個以上のシーケンスとしてエンコードされます。</dd><dt><code>tag := (field &lt;&lt; 3) bit-or wire_type</code></dt><dd>タグは、最下位 3 ビットに格納された <code>wire_type</code> と、<code>.proto</code> ファイルで定義されたフィールド番号の組み合わせです。</dd><dt><code>value := varint for wire_type == VARINT, ...</code></dt><dd>値は、タグで指定された <code>wire_type</code> に応じて異なる方法で格納されます。</dd><dt><code>varint := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64</code></dt><dd>リストされたデータ型のいずれかを格納するために varint を使用できます。</dd><dt><code>i32 := sfixed32 | fixed32 | float</code></dt><dd>リストされたデータ型のいずれかを格納するために fixed32 を使用できます。</dd><dt><code>i64 := sfixed64 | fixed64 | double</code></dt><dd>リストされたデータ型のいずれかを格納するために fixed64 を使用できます。</dd><dt><code>len-prefix := size (message | string | bytes | packed)</code></dt><dd>長さ接頭辞付きの値は、長さ（varint としてエンコードされた）と、その後にリストされたデータ型のいずれかが格納されます。</dd><dt><code>string := valid UTF-8 string (e.g. ASCII)</code></dt><dd>記述されているように、文字列は UTF-8 文字エンコーディングを使用する必要があります。文字列は 2GB を超えることはできません。</dd><dt><code>bytes := any sequence of 8-bit bytes</code></dt><dd>記述されているように、バイトはカスタムデータ型を格納でき、最大 2GB のサイズまでです。</dd><dt><code>packed := varint* | i32* | i64*</code></dt><dd>プロトコル定義で説明されているタイプの連続した値を格納する場合は、<code>packed</code> データ型を使用します。最初の値以降の値にはタグが削除され、フィールドごとではなく要素ごとにタグのコストが均等化されます。</dd></dl><p>Please provide the Markdown content you would like me to translate into Japanese.</p></main><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2024 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>プライバシーポリシー</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/js/main.min.ba08a6b7f24e657f0a1b9b55be3a3162585168cd862ace0957f5b44e6cb6dc61.js integrity="sha256-ugimt/JOZX8KG5tVvjoxYlhRaM2GKs4JV/W0Tmy23GE=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>