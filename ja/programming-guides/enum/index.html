<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=ja class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.121.2"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Protocol Buffers Documentation</title>
<meta name=description content="列挙型の動作 列挙型は、異なる言語ライブラリで異なる動作をします。このトピックでは、異なる動作と、protobuf をすべての言語で一貫した状態に移行する計画について説明します。一般的な列挙型の使用方法については、proto2 および proto3 言語ガイドの対応するセクションを参照してください。
列挙型には、2 つの異なるフレーバー（オープン と クローズド）があります。未知の値の処理を除いて、それらは同じように動作します。実際には、単純なケースでは同じように動作しますが、いくつかの特殊なケースには興味深い影響があります。
説明のために、次の .proto ファイルがあると仮定しましょう（現時点では syntax = &amp;quot;proto2&amp;quot; または syntax = &amp;quot;proto3&amp;quot; ファイルであるかどうかは意図的に指定していません）:
enum Enum { A = 0; B = 1; } message Msg { optional Enum enum = 1; } オープン と クローズド の区別は、1 つの質問で表すことができます:
プログラムが値 2 を持つフィールド 1 を含むバイナリデータを解析するとき、何が起こりますか？
オープン 列挙型は値 2 を解析し、それを直接フィールドに格納します。アクセサはフィールドを 設定 として報告し、2 を表すものを返します。 クローズド 列挙型は値 2 を解析し、メッセージの未知のフィールドセットに格納します。アクセサはフィールドを 未設定 として報告し、列挙型のデフォルト値を返します。 クローズド 列挙型の影響 クローズド 列挙型の動作には、繰り返しフィールドを解析する際に予期しない結果があります。repeated Enum フィールドを解析すると、すべての未知の値が未知のフィールドセットに配置されます。シリアライズされると、これらの未知の値は再度書き込まれますが、元のリスト内の元の位置には書き込まれません。たとえば、次の .proto ファイルが与えられた場合:"><meta property="og:title" content><meta property="og:description" content="列挙型の動作 列挙型は、異なる言語ライブラリで異なる動作をします。このトピックでは、異なる動作と、protobuf をすべての言語で一貫した状態に移行する計画について説明します。一般的な列挙型の使用方法については、proto2 および proto3 言語ガイドの対応するセクションを参照してください。
列挙型には、2 つの異なるフレーバー（オープン と クローズド）があります。未知の値の処理を除いて、それらは同じように動作します。実際には、単純なケースでは同じように動作しますが、いくつかの特殊なケースには興味深い影響があります。
説明のために、次の .proto ファイルがあると仮定しましょう（現時点では syntax = &#34;proto2&#34; または syntax = &#34;proto3&#34; ファイルであるかどうかは意図的に指定していません）:
enum Enum { A = 0; B = 1; } message Msg { optional Enum enum = 1; } オープン と クローズド の区別は、1 つの質問で表すことができます:
プログラムが値 2 を持つフィールド 1 を含むバイナリデータを解析するとき、何が起こりますか？
オープン 列挙型は値 2 を解析し、それを直接フィールドに格納します。アクセサはフィールドを 設定 として報告し、2 を表すものを返します。 クローズド 列挙型は値 2 を解析し、メッセージの未知のフィールドセットに格納します。アクセサはフィールドを 未設定 として報告し、列挙型のデフォルト値を返します。 クローズド 列挙型の影響 クローズド 列挙型の動作には、繰り返しフィールドを解析する際に予期しない結果があります。repeated Enum フィールドを解析すると、すべての未知の値が未知のフィールドセットに配置されます。シリアライズされると、これらの未知の値は再度書き込まれますが、元のリスト内の元の位置には書き込まれません。たとえば、次の .proto ファイルが与えられた場合:"><meta property="og:type" content="article"><meta property="og:url" content="https://protobuf.dev/ja/programming-guides/enum/"><meta property="article:section" content="programming-guides"><meta itemprop=name content><meta itemprop=description content="列挙型の動作 列挙型は、異なる言語ライブラリで異なる動作をします。このトピックでは、異なる動作と、protobuf をすべての言語で一貫した状態に移行する計画について説明します。一般的な列挙型の使用方法については、proto2 および proto3 言語ガイドの対応するセクションを参照してください。
列挙型には、2 つの異なるフレーバー（オープン と クローズド）があります。未知の値の処理を除いて、それらは同じように動作します。実際には、単純なケースでは同じように動作しますが、いくつかの特殊なケースには興味深い影響があります。
説明のために、次の .proto ファイルがあると仮定しましょう（現時点では syntax = &#34;proto2&#34; または syntax = &#34;proto3&#34; ファイルであるかどうかは意図的に指定していません）:
enum Enum { A = 0; B = 1; } message Msg { optional Enum enum = 1; } オープン と クローズド の区別は、1 つの質問で表すことができます:
プログラムが値 2 を持つフィールド 1 を含むバイナリデータを解析するとき、何が起こりますか？
オープン 列挙型は値 2 を解析し、それを直接フィールドに格納します。アクセサはフィールドを 設定 として報告し、2 を表すものを返します。 クローズド 列挙型は値 2 を解析し、メッセージの未知のフィールドセットに格納します。アクセサはフィールドを 未設定 として報告し、列挙型のデフォルト値を返します。 クローズド 列挙型の影響 クローズド 列挙型の動作には、繰り返しフィールドを解析する際に予期しない結果があります。repeated Enum フィールドを解析すると、すべての未知の値が未知のフィールドセットに配置されます。シリアライズされると、これらの未知の値は再度書き込まれますが、元のリスト内の元の位置には書き込まれません。たとえば、次の .proto ファイルが与えられた場合:"><meta itemprop=wordCount content="258"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="列挙型の動作 列挙型は、異なる言語ライブラリで異なる動作をします。このトピックでは、異なる動作と、protobuf をすべての言語で一貫した状態に移行する計画について説明します。一般的な列挙型の使用方法については、proto2 および proto3 言語ガイドの対応するセクションを参照してください。
列挙型には、2 つの異なるフレーバー（オープン と クローズド）があります。未知の値の処理を除いて、それらは同じように動作します。実際には、単純なケースでは同じように動作しますが、いくつかの特殊なケースには興味深い影響があります。
説明のために、次の .proto ファイルがあると仮定しましょう（現時点では syntax = &#34;proto2&#34; または syntax = &#34;proto3&#34; ファイルであるかどうかは意図的に指定していません）:
enum Enum { A = 0; B = 1; } message Msg { optional Enum enum = 1; } オープン と クローズド の区別は、1 つの質問で表すことができます:
プログラムが値 2 を持つフィールド 1 を含むバイナリデータを解析するとき、何が起こりますか？
オープン 列挙型は値 2 を解析し、それを直接フィールドに格納します。アクセサはフィールドを 設定 として報告し、2 を表すものを返します。 クローズド 列挙型は値 2 を解析し、メッセージの未知のフィールドセットに格納します。アクセサはフィールドを 未設定 として報告し、列挙型のデフォルト値を返します。 クローズド 列挙型の影響 クローズド 列挙型の動作には、繰り返しフィールドを解析する際に予期しない結果があります。repeated Enum フィールドを解析すると、すべての未知の値が未知のフィールドセットに配置されます。シリアライズされると、これらの未知の値は再度書き込まれますが、元のリスト内の元の位置には書き込まれません。たとえば、次の .proto ファイルが与えられた場合:"><link rel=preload href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css as=style><link href=/scss/main.min.6a57e8f3f347dea5d31cb48e3b4ea9fdae32d499473089bdef9b45457b5debb8.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/ja/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Protocol Buffers Documentation</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item dropdown mr-4 d-none d-lg-block"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語</a><div class=dropdown-menu aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/programming-guides/enum/>English</a></div></li></ul></div><div class="navbar-nav d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder=サイトを検索... aria-label=サイトを検索... autocomplete=off></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><h2 id=definitions>列挙型の動作</h2><p>列挙型は、異なる言語ライブラリで異なる動作をします。このトピックでは、異なる動作と、protobuf をすべての言語で一貫した状態に移行する計画について説明します。一般的な列挙型の使用方法については、<a href=/programming-guides/proto2#enum>proto2</a> および <a href=/programming-guides/proto3#enum>proto3</a> 言語ガイドの対応するセクションを参照してください。</p><p>列挙型には、2 つの異なるフレーバー（<em>オープン</em> と <em>クローズド</em>）があります。未知の値の処理を除いて、それらは同じように動作します。実際には、単純なケースでは同じように動作しますが、いくつかの特殊なケースには興味深い影響があります。</p><p>説明のために、次の <code>.proto</code> ファイルがあると仮定しましょう（現時点では <code>syntax = "proto2"</code> または <code>syntax = "proto3"</code> ファイルであるかどうかは意図的に指定していません）:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#204a87;font-weight:700>enum</span> <span style=color:#000>Enum</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>A</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>B</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>message</span> <span style=color:#000>Msg</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>optional</span> <span style=color:#000>Enum</span> <span style=color:#204a87;font-weight:700>enum</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p><em>オープン</em> と <em>クローズド</em> の区別は、1 つの質問で表すことができます:</p><blockquote><p>プログラムが値 <code>2</code> を持つフィールド 1 を含むバイナリデータを解析するとき、何が起こりますか？</p></blockquote><ul><li><strong>オープン</strong> 列挙型は値 <code>2</code> を解析し、それを直接フィールドに格納します。アクセサはフィールドを <em>設定</em> として報告し、<code>2</code> を表すものを返します。</li><li><strong>クローズド</strong> 列挙型は値 <code>2</code> を解析し、メッセージの未知のフィールドセットに格納します。アクセサはフィールドを <em>未設定</em> として報告し、列挙型のデフォルト値を返します。</li></ul><h2 id=クローズド-列挙型の影響><em>クローズド</em> 列挙型の影響</h2><p><em>クローズド</em> 列挙型の動作には、繰り返しフィールドを解析する際に予期しない結果があります。<code>repeated Enum</code> フィールドを解析すると、すべての未知の値が<a href=/programming-guides/proto3/#unknowns>未知のフィールド</a>セットに配置されます。シリアライズされると、これらの未知の値は再度書き込まれますが、<em>元のリスト内の元の位置には書き込まれません</em>。たとえば、次の <code>.proto</code> ファイルが与えられた場合:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#204a87;font-weight:700>enum</span> <span style=color:#000>Enum</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>A</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>B</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>message</span> <span style=color:#000>Msg</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>repeated</span> <span style=color:#000>Enum</span> <span style=color:#000>r</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>ワイヤーフォーマットには、フィールド1の値として <code>[0, 2, 1, 2]</code> を含むものがあります。この場合、繰り返しフィールドには <code>[0, 1]</code> が含まれ、値 <code>[2, 2]</code> は未知のフィールドとして格納されます。メッセージを再シリアル化した後、ワイヤーフォーマットは <code>[0, 1, 2, 2]</code> に対応します。</p><p>同様に、値が未知の場合、<em>closed</em> 列挙型を持つマップは、その値が未知の場合には、エントリ全体（キーと値）を未知のフィールドに配置します。</p><h2 id=history>履歴</h2><p><code>syntax = "proto3"</code> の導入以前、すべての列挙型は <em>closed</em> でした。Proto3 は <em>closed</em> 列挙型が引き起こす予期しない動作のために <em>open</em> 列挙型を導入しました。</p><h2 id=spec>仕様</h2><p>以下は、protobuf の準拠実装の動作を指定しています。これは微妙な点であるため、多くの実装が準拠していません。異なる実装がどのように振る舞うかの詳細については、<a href=#known-issues>既知の問題</a> を参照してください。</p><ul><li><code>proto2</code> ファイルが <code>proto2</code> ファイルで定義された列挙型をインポートする場合、その列挙型は <strong>closed</strong> として扱われるべきです。</li><li><code>proto3</code> ファイルが <code>proto3</code> ファイルで定義された列挙型をインポートする場合、その列挙型は <strong>open</strong> として扱われるべきです。</li><li><code>proto3</code> ファイルが <code>proto2</code> ファイルで定義された列挙型をインポートする場合、<code>protoc</code> コンパイラはエラーを出力します。</li><li><code>proto2</code> ファイルが <code>proto3</code> ファイルで定義された列挙型をインポートする場合、その列挙型は <strong>open</strong> として扱われるべきです。</li></ul><h2 id=known-issues>既知の問題</h2><h3 id=cpp>C++</h3><p>すべての既知の C++ リリースは準拠していません。<code>proto2</code> ファイルが <code>proto3</code> ファイルで定義された列挙型をインポートする場合、C++ はそのフィールドを <strong>closed</strong> 列挙型として扱います。</p><h3 id=csharp>C#</h3><p>すべての既知の C# リリースは準拠していません。C# はすべての列挙型を <strong>open</strong> として扱います。</p><h3 id=java>Java</h3><p>すべての既知の Java リリースは準拠していません。<code>proto2</code> ファイルが <code>proto3</code> ファイルで定義された列挙型をインポートする場合、Java はそのフィールドを <strong>closed</strong> 列挙型として扱います。</p><blockquote><p><strong>注意:</strong> Java における <strong>open</strong> 列挙型の扱いには驚くべきエッジケースがあります。次の定義が与えられた場合：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#000>syntax</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;proto3&#34;</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#204a87;font-weight:700>enum</span> <span style=color:#000>Enum</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>A</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>  <span style=color:#000>B</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>message</span> <span style=color:#000>Msg</span> <span style=color:#000;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#000>repeated</span> <span style=color:#000>Enum</span> <span style=color:#000>name</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>}</span>
</span></span></code></pre></div><p>Java は <code>Enum getName()</code> および <code>int getNameValue()</code> メソッドを生成します。<code>getName</code> メソッドは既知のセット外の値（たとえば <code>2</code> など）に対して <code>Enum.UNRECOGNIZED</code> を返し、<code>getNameValue</code> は <code>2</code> を返します。</p><p>同様に、Java は <code>Builder setName(Enum value)</code> および <code>Builder setNameValue(int value)</code> メソッドを生成します。<code>setName</code> メソッドは <code>Enum.UNRECOGNIZED</code> が渡された場合に例外をスローし、<code>setNameValue</code> は <code>2</code> を受け入れます。</p></blockquote><h3 id=java>Kotlin</h3><p>すべての既知のKotlinリリースは適合性を満たしていません。<code>proto2</code>ファイルが<code>proto3</code>ファイルで定義された列挙型をインポートすると、Kotlinはそのフィールドを<strong>クローズド</strong>列挙型として扱います。</p><p>KotlinはJava上に構築されており、そのすべての特異性を共有しています。</p><h3 id=go>Go</h3><p>すべての既知のGoリリースは適合性を満たしていません。Goはすべての列挙型を<strong>オープン</strong>として扱います。</p><h3 id=jspb>JSPB</h3><p>すべての既知のJSPBリリースは適合性を満たしていません。JSPBはすべての列挙型を<strong>オープン</strong>として扱います。</p><h3 id=php>PHP</h3><p>PHPは適合しています。</p><h3 id=python>Python</h3><p>4.22.0以降、Pythonは適合しています。</p><p>4.21.xでは、Pythonはデフォルトで適合していますが、<code>PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python</code>を設定すると適合性を満たさなくなります。</p><p>4.21.0より前では、Pythonは適合していません。</p><p><code>proto2</code>ファイルが<code>proto3</code>ファイルで定義された列挙型をインポートすると、適合していないPythonバージョンはそのフィールドを<strong>クローズド</strong>列挙型として扱います。</p><h3 id=ruby>Ruby</h3><p>すべての既知のRubyリリースは適合性を満たしていません。Rubyはすべての列挙型を<strong>オープン</strong>として扱います。</p><h3 id=obj-c>Objective-C</h3><p>22.0以降、Objective-Cは適合しています。</p><p>22.0より前では、Objective-Cは適合していませんでした。<code>proto2</code>ファイルが<code>proto3</code>ファイルで定義された列挙型をインポートすると、そのフィールドを<strong>クローズド</strong>列挙型として扱いました。</p><h3 id=swift>Swift</h3><p>Swiftは適合しています。</p><h3 id=dart>Dart</h3><p>Dartはすべての列挙型を<strong>クローズド</strong>として扱います。</p></main><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2024 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>プライバシーポリシー</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/js/main.min.ba08a6b7f24e657f0a1b9b55be3a3162585168cd862ace0957f5b44e6cb6dc61.js integrity="sha256-ugimt/JOZX8KG5tVvjoxYlhRaM2GKs4JV/W0Tmy23GE=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>